# C++11

C++11 とは 2011年に新たに制定された C++ の新しい機能や記法のことです。以前の記法と比べ、C++ を初心者にも扱いやすくする機能も数多く追加されているため、本ドキュメントでは C++11 の機能を積極的に利用してゆきます。

**【重要】本ドキュメントのコード例は基本的にC++11が有効であることを前提とします**。


## C++11 を有効にする

C++11を有効にするには Rcpp コード中に次の記述を追加します。

```cpp
// [[Rcpp::plugins("cpp11")]]
```

##おすすめ C++11 機能


### 初期化リスト

`{}`を使った変数の初期化。

```
// Vector の初期化
//次の3つは同じ値 c(1,2,3) となります。
NumericVector v1 = NumericVector::create(1.0, 2.0, 3.0);
NumericVector v2 = {1.0, 2.0, 3.0};
NumericVector v3   {1.0, 2.0, 3.0}; // = は省略できます。
```


### auto

`auto` を使うと、宣言する変数の型を、代入する値に合わせて、自動的に設定してくれます。

```
// i は int
auto  i  = 4;

NumericVector v;
// it は NumericVector::iterator
auto it = v.begin();
```


### decltype

`decltype`を使うと、既存の変数や式と同じ型の変数を宣言することができます。

```
int i;
decltype(i) x; // x は int型 となる
```


### 範囲 for

R と同じスタイルで for 文を記述できます。


```
IntegerVector v{1,2,3};
int sum=0;
for(auto& x : v) {
  sum += x;
}
```


### ラムダ式

ラムダ式は関数オブジェクトを簡単に作成するための記法です。

ラムダ式は `[](){}` の書式で記述します。

* `[]` には、関数オブジェクト内で利用したいローカル変数のリストを記述します。
    * `[=]`は、全てのローカル変数の値をコピーして利用できます。
    * `[&]`は、全てのローカル変数に直接アクセスできます。
    * `[=x, &y]` ローカル変数 x は値をコピーして利用できます。、ローカル変数 y には直接アクセスできます。
    * `[]` は、ローカル変数にはアクセスしません。
* `()`には、この関数オブジェクトに渡す引数を記述します。
* `{}`には、処理内容を記述します。


この関数オブジェクトの返値の型は、`{}`内でリターンされた値の型が自動的に設定されます。明示的に記述したい場合には、`[]()->int{}` のように記述します。

ラムダ式を用いることで、C++ でも R と同様のスタイルでコードを記述できます。ことを、次の例は示しています。

``` R
v <- c(1,2,3,4,5)
A <- 2.0
res <-
  sapply(v, function(x){A*x})
```

``` cpp
// [[Rcpp::plugins("cpp11")]]
// [[Rcpp::export]]
NumericVector rcpp_lambda_1(){
  NumericVector v = {1,2,3,4,5};
  double A = 2.0;
  NumericVector res =
    sapply(v, [&](double x){return A*x;});
  return res;
}
```

ラムダ式で作成した関数オブジェクトは保存しておくこともできます。

```cpp
// [[Rcpp::export]]
void rcpp_lambda_2(){
  NumericVector v  {1,2,3};

  //ラムダ式を保存します
  auto square = [](double x){return x*x;};

  //保存した関数オブジェクトを使用します
  double x = square(10.0);

  Rcout << x << "\n";

}   

```
