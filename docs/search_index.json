[
["index.html", "みんなのRcpp はじめに", " みんなのRcpp Masaki E. Tsuda 2017-07-02 はじめに Rcpp は R の関数を C++ で実装することを可能にするパッケージです。 R と類似したスタイルで記述できるように実装されているため、C++ に深い知識がなくても利用しやすいようになっています。しかも、そのために実行速度は犠牲にされていないので、誰でもハイパフォーマンスな結果を得ることができます。 このドキュメントは、C++にもそれほど詳しくない方々に対しても Rcpp を利用するのに必要な情報を提供することを目的としています。そのため、場合によっては C++的に正確な記述することよりも、概念的なコード例を使って説明している場合があります。 C++の書き方そのものについての説明はほどんどありませんので、C++についてはその他の資料を参考にしてください。本書を読んで C++ を学んでみようという方には「基礎からしっかり学ぶC++の教科書 矢吹 太朗 著（日経BP社）」をオススメいたします。 このドキュメントへのフィードバックは Github の issue でいただけますとありがたいです。 https://github.com/teuder/rcpp4everyone_ja "],
["010_Rcpp_merit.html", "Chapter 1 Rcppの活用ポイント", " Chapter 1 Rcppの活用ポイント Rと比べて C++ で書くことによって特に高速化が見込めるのは次のようなケースです。 繰り返し処理、特に次の処理が前の処理に依存しており並列化できない場合 ベクターや行列の個々の要素へアクセスする場合 繰り返し関数の呼び出しがある場合 ベクターのサイズを動的に変更する場合 高度なデータ構造やアルゴリズムを用いた処理 "],
["020_install.html", "Chapter 2 インストール 2.1 C++コンパイラのインストール 2.2 Rcpp のインストール", " Chapter 2 インストール Rcppを使って開発を行うためには C++ のコンパイラをインストールする必要があります。 2.1 C++コンパイラのインストール 2.1.1 Windows Rtools をインストールします。Rtoolsをインストールする際には、自分がインストールしているRのバージョンにあったものをインストールするように気をつけてください。 2.1.2 Mac ターミナルで次のコマンドを打ち Xcode command line tools をインストールします。 xcode-select --install 2.1.3 Linux ディストリビューションにより方法が異なります。 例えば、Ubuntu であれば以下のコマンドを打ちます。 sudo apt-get install r-base-dev 2.1.4 その他の自分でインストールしたコンパイラを使いたい場合 自分でインストールした g++ や clang++ などのコンパイラを使いたい場合には、ユーザーのホームディレクトリ以下に次のファイルを作成し、そこに環境変数の設定を記述します。 Linux, Mac .R/Makevars Windows .R/Makevars.win 環境変数の設定例 CC=/opt/local/bin/gcc-mp-4.7 CXX=/opt/local/bin/g++-mp-4.7 CPLUS_INCLUDE_PATH=/opt/local/include:$CPLUS_INCLUDE_PATH LD_LIBRARY_PATH=/opt/local/lib:$LD_LIBRARY_PATH CXXFLAGS= -g0 -O3 -Wall MAKE=make -j4 ユーザーのホームディレクトリ ちなみに、ユーザーのホームディレクトリは R から次のコードを実行することで調べることができます。 path.expand(&quot;~&quot;) 2.2 Rcpp のインストール コンパイラがインストールできたら、R で Rcpp パッケージをインストールします。 install.packages(&quot;Rcpp&quot;) "],
["030_basic_usage.html", "Chapter 3 基本的な使い方 3.1 Rcppコードを書く 3.2 コンパイル 3.3 実行結果", " Chapter 3 基本的な使い方 Rcppで記述した関数を実行するまでの流れは次のとおりです。 Rcppのコードを書く コンパイル 実行する 3.1 Rcppコードを書く まずは、Rcppのファイルを作成します。下の例では、数値ベクターの要素の総和を計算する関数 rcpp_sum() を定義しています。このコードを sum.cpp という名前で保存します。 #include &lt;Rcpp.h&gt; using namespace Rcpp; // [[Rcpp::export]] double rcpp_sum(NumericVector v){ double sum = 0; for(int i=0; i&lt;v.length(); ++i){ sum += v[i]; } return(sum); } 3.2 コンパイル sourceCpp() がソースコードのコンパイルと R へのロードをしてくれるます。 library(Rcpp) sourceCpp(&#39;sum.cpp&#39;) 3.3 実行結果 &gt; rcpp_sum(1:10) [1] 55 &gt; sum(1:10) [1] 55 "],
["040_function.html", "Chapter 4 Rcppにおける関数定義の基本形", " Chapter 4 Rcppにおける関数定義の基本形 Rcpp で関数を定義する際の基本形を下に示します。 #include&lt;Rcpp.h&gt; using namespace Rcpp; // [[Rcpp::export]] 返値型 関数名(引数型 引数){ ... return 返値; } #include&lt;Rcpp.h&gt;：Rcppで定義されたデータ型や関数を利用するために必要なヘッダファイルをインクルードします。 // [[Rcpp::export]]：この直下に記述された関数がRで利用できるようになります。 using namespace Rcpp この文は必須ではないが、これを記述すると、Rcppの変数や関数名にRcpp::を付ける必要がなくなります。 返値型 関数名(引数型 引数){}：C++では関数の返値や引数の型を指定する必要があります。 return 返値：関数の返値は return 文 により明示的に指定する必要があります。 引数や返値として標準 C++ のデータ構造を指定することもできます。詳細は 標準C++データ構造の項を参照。 "],
["050_c++11.html", "Chapter 5 C++11 5.1 C++11 を有効にする 5.2 おすすめ C++11 機能", " Chapter 5 C++11 C++11 とは 2011年に新たに制定された C++ の新しい機能や記法のことです。以前の記法と比べ、C++ を初心者にも扱いやすくする機能も数多く追加されているため、本ドキュメントでは C++11 の機能を積極的に利用してゆきます。 【重要】本ドキュメントのコード例は基本的にC++11が有効であることを前提とします。 5.1 C++11 を有効にする C++11を有効にするには Rcpp コード中に次の記述を追加します。 // [[Rcpp::plugins(&quot;cpp11&quot;)]] 5.2 おすすめ C++11 機能 5.2.1 初期化リスト {}を使った変数の初期化。 // Vector の初期化 //次の3つは同じ値 c(1,2,3) となります。 NumericVector v1 = NumericVector::create(1.0, 2.0, 3.0); NumericVector v2 = {1.0, 2.0, 3.0}; NumericVector v3 {1.0, 2.0, 3.0}; // = は省略できます。 5.2.2 auto auto を使うと、宣言する変数の型を、代入する値に合わせて、自動的に設定してくれます。 // i は int auto i = 4; NumericVector v; // it は NumericVector::iterator auto it = v.begin(); 5.2.3 decltype decltypeを使うと、既存の変数や式と同じ型の変数を宣言することができます。 int i; decltype(i) x; // x は int型 となる 5.2.4 範囲 for R と同じスタイルで for 文を記述できます。 IntegerVector v{1,2,3}; int sum=0; for(auto&amp; x : v) { sum += x; } 5.2.5 ラムダ式 ラムダ式は関数オブジェクトを簡単に作成するための記法です。 ラムダ式は [](){} の書式で記述します。 [] には、関数オブジェクト内で利用したいローカル変数のリストを記述します。 [=]は、全てのローカル変数の値をコピーして利用できます。 [&amp;]は、全てのローカル変数に直接アクセスできます。 [=x, &amp;y] ローカル変数 x は値をコピーして利用できます。、ローカル変数 y には直接アクセスできます。 [] は、ローカル変数にはアクセスしません。 ()には、この関数オブジェクトに渡す引数を記述します。 {}には、処理内容を記述します。 この関数オブジェクトの返値の型は、{}内でリターンされた値の型が自動的に設定されます。明示的に記述したい場合には、[]()-&gt;int{} のように記述します。 ラムダ式を用いることで、C++ でも R と同様のスタイルでコードを記述できます。ことを、次の例は示しています。 v &lt;- c(1,2,3,4,5) A &lt;- 2.0 res &lt;- sapply(v, function(x){A*x}) // [[Rcpp::plugins(&quot;cpp11&quot;)]] // [[Rcpp::export]] NumericVector rcpp_lambda_1(){ NumericVector v = {1,2,3,4,5}; double A = 2.0; NumericVector res = sapply(v, [&amp;](double x){return A*x;}); return res; } ラムダ式で作成した関数オブジェクトは保存しておくこともできます。 // [[Rcpp::export]] void rcpp_lambda_2(){ NumericVector v {1,2,3}; //ラムダ式を保存します auto square = [](double x){return x*x;}; //保存した関数オブジェクトを使用します double x = square(10.0); Rcout &lt;&lt; x &lt;&lt; &quot;\\n&quot;; } "],
["060_utility.html", "Chapter 6 コンソール画面への出力", " Chapter 6 コンソール画面への出力 メッセージやオブジェクトの値を画面に表示するためには Rprintf() か Rcout を用います。エラー表示のためには REprintf() か Rcerr を用います。 Rcout Rcerr の使い方は標準 C++ の cout cerr と同じで、出力したい順に文字列や変数を &lt;&lt; でつなげて記述します。なお、Vector 型の変数を与えると全要素を表示します。 // [[Rcpp::export]] void rcpp_rcout(NumericVector v){ // Rcout にベクトル変数を与えると全要素を表示します Rcout &lt;&lt; &quot;The value of v : &quot; &lt;&lt; v &lt;&lt; &quot;\\n&quot;; // エラーメッセージを表示する際は Rcerr を用いる Rcerr &lt;&lt; &quot;Error message&quot; &lt;&lt; &quot;\\n&quot;; } Rprintf() 関数と REprintf() 関数の使い方は標準 C にある printf() 関数と同じで、書式を指定して変数の値を出力します。 Rprintf( 書式文字列, 変数) 書式文字列の中で変数の値を用いたい部分には % から始まる書式指定子を記述します。書式指定子は書式文字列のなかで複数記述することもでき、その場合は、書式文字列の中で書式指定子が現れる順に、表示したい変数を引数として渡します。 使用できる書式指定子の一部を下の表に示します。詳細は C 言語の解説書などを参考にしてください。 書式指定子 説明 %i 整数 (int) の引数を表示します %u 符号無し整数 (unsigned int) の引数を表示します %f 実数 (double) の引数を小数形式で表示します %e 実数 (double) の引数を指数形式で表示します %c 1文字 (char) の引数を表示します %s 文字列 (char*) の引数を表示します なお、Rprintf() 関数で表示できる変数の型は標準 C で提供されている型に限られるので、Rcpp の NumericVector など Rcpp で定義されている型は Rprintf() 関数の引数として与えて表示することはできません。ただし、Rcpp のベクトルの要素の１つ１つは int や double など標準 C で提供されている基本的な型なので表示することができます。そのため、Rprintf() 関数でベクトルの全要素を表示する場合には、下のコード例のように for ループを用います // [[Rcpp::export]] void rcpp_rprintf(NumericVector v){ // Rprintf でベクトルの全要素を表示する for(int i=0; i&lt;v.length(); ++i){ Rprintf(&quot;the value of v[%i] : %f \\n&quot;, i, v[i]); } } "],
["070_data_types.html", "Chapter 7 基本データ型とデータ構造 7.1 基本データ型 7.2 データ構造", " Chapter 7 基本データ型とデータ構造 Rcpp では R の全てのデータ型とデータ構造を利用することができます。ユーザーは Rcpp で提供される様々なクラスを通して、実行中の R のメモリにあるオブジェクトを直接操作することができます。この章では Rcpp で利用できるデータ型とデータ構造を紹介します。 7.1 基本データ型 R には基本的なデータ型として、logical（論理値）、integer（整数）、numeric（実数）、complex（複素数）、character（文字列）、Date（日付）、POSIXct（日時） があります。Rcpp には、これらと対応したベクトル型と行列型が定義されています。ただし、日付と日時については R と同様にベクトル型だけが定義されています。 本書ではこれ以降 Rcpp が提供するベクトル型と行列型を総称するために Vector、 Matrix という語を用います。 R、Rcpp、C++ で利用できる基本的なデータ型の対応関係をまとめると下の表のようになります。 Rベクトル Rcppベクトル型 Rcpp行列型 Rcppスカラー型 C++スカラー型 論理 logical NumericVector NumericMatrix - bool 整数 integer IntegerVector IntegerMatrix - int 実数 numeric NumericVector NumericMatrix - double 複素数 complex ComplexVector ComplexMatrix Rcomplex complex 文字列 character CharacterVector (StringVector) CharacterMatrix (StringMatrix) String string 日付 Date DateVector - Date - 日時 POSIXct DatetimeVector - Datetime time_t 7.2 データ構造 R にはベクトル、行列の他にデータフレーム、リスト、S3 クラス、S4 クラスのデータ構造がありますが、Rcpp はそれら全てを扱うことができます。 下の表に R と Rcpp のデータ構造の対応関係を示します。 R データ構造 Rcpp データ構造 data.frame DataFrame list List S3 クラス List S4 クラス S4 Dataframe は、様々な型のベクトルを要素として格納することができます。しかし、要素となる全てのベクトルの長さは等しいという制約があります。 List は、Dataframe や List を含む、どのような型のオブジェクトでも要素として持つことができます。要素となるベクトルの長さにも制限はありません。 S3 クラスは属性 class に独自の名前が設定されたリストですので、使い方は List と同様です。 S4 クラスはスロット（slot）と呼ばれる内部データを持っています。Rcpp の S4 を用いることで R で定義した S4 クラスのオブジェクトの作成、および、スロットへのアクセスが可能になります。 また、Rcpp では Vector, List, DataFrame は、どれもある種のベクトルとして実装されています。つまり、Vector は、スカラー値を要素とするベクトル、DataFrame は同じ長さの Vector オブジェクトを要素とするベクトル、List は任意のオブジェクトを要素とするベクトルです。そのため、Vector, List, DataFrame は多くの共通するメンバー関数を持っています。 "],
["080_vector.html", "Chapter 8 Vector 8.1 Vectorオブジェクトの作成 8.2 Vector要素へのアクセス 8.3 メンバ関数 8.4 静的メンバ関数", " Chapter 8 Vector ベクトルオブジェクトの作成 ベクトル要素へのアクセス メンバ関数 静的メンバ関数 8.1 Vectorオブジェクトの作成 // v &lt;- rep(0, 3) と同等 NumericVector v (3); // v &lt;- rep(1, 3) と同等 NumericVector v (3,1); // v &lt;- c(1,2,3) と同等 NumericVector v = NumericVector::create(1,2,3); // v &lt;- c(1,2,3) と同等、C++11 の初期化リストで作成 NumericVector v = {1,2,3}; // v &lt;- c(x=1, y=2, z=3) と同様 名前付きベクトル NumericVector v = NumericVector::create(Named(&quot;x&quot;,1), Named(&quot;y&quot;)=2 , _[&quot;z&quot;]=3); 8.2 Vector要素へのアクセス Rと同様に、要素番号（整数・実数ベクトル）、要素名（文字列ベクトル）、論理ベクトルを用いて、ベクターの要素にアクセスして、値の取得・代入を行うことができます。 要素へのアクセスには [] または () を用います。[] を用いた場合はベクトルの範囲外へのアクセスを無視しますが、() を用いた場合は実行時にエラーとなります。 また、要素番号を用いて Rcpp でベクトルの要素にアクセスする際に気をつけるべき重要な点として、R ではベクトルの最初の要素は 1 番であるのに対して、Rcpp では 0 番から始まるということがあります。間違いやすいので注意してください。 【重要】： Rcpp は C++ のスタイルに従い、ベクトルや行列の要素番号は ０ から始まります。 // [[Rcpp::export]] void rcpp_vector_access(){ //ベクトルの作成 NumericVector v {10,20,30,40,50}; //要素名を設定します v.names() = CharacterVector({&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;}); //ベクトルの要素にアクセスするためのベクトルを用意します NumericVector numeric = {1,3}; IntegerVector integer = {1,3}; CharacterVector character = {&quot;B&quot;,&quot;D&quot;}; LogicalVector logical = {false, true, false, true, false}; //ベクトル要素の値を取得します double x1 = v[0]; double x2 = v[&quot;A&quot;]; NumericVector res1 = v[numeric]; NumericVector res2 = v[integer]; NumericVector res3 = v[character]; NumericVector res4 = v[logical]; //ベクトル要素へ値を代入します v[0] = 100; v[&quot;A&quot;] = 100; NumericVector v2 {100,200}; v[numeric] = v2; v[integer] = v2; v[character] = v2; v[logical] = v2; } 8.3 メンバ関数 メンバ関数（メソッドとも呼ばれる）とは、個々のオブジェクトと結びついた関数です。呼び出し方が通常の関数とは少し異なっており、 v.length() のような形式で呼び出す。 NumericVector v = {1,2,3,4,5}; int n = v.length(); // 5 8.3.1 length() size() 要素数を返します。 8.3.2 names() 要素名を文字列ベクトルで返します。 8.3.3 offset(name) findName(name) 文字列 name で指定した要素名の要素の要素番号を返します。 8.3.4 fill(x) このベクトルの全ての要素をスカラー値 x で埋めます。 8.3.5 sort() このベクトルを昇順でソートしたベクトルを返します。 8.3.6 assign( first_it, last_it) イテレータ first_it、last_it で指定された範囲の値を、このベクトルに代入します。 8.3.7 push_back(x) このベクトルの末尾にスカラー値 x を追加します。 8.3.8 push_back( x, name ) このベクトルの末尾にスカラー値 x を追加します。追加した要素の名前を文字列 name で指定します。 8.3.9 push_front(x) このベクトルの先頭にスカラー値 x を追加します。 8.3.10 push_front( x, name ) このベクトルの先頭にスカラー値 x を追加します。追加した要素の名前を文字列 name で指定します。 8.3.11 begin() このベクトルの先頭を指し示すイテレータを返します。 8.3.12 end() このベクトルの末尾（最後の要素の１個後ろ）を指し示すイテレータを返します。 8.3.13 insert( i, x ) このベクトルの要素番号 i の位置の前にスカラー値 x を追加し、追加された要素へのイテレータを返します。 8.3.14 insert( it, x ) このベクトルのイテレータ it で指し示す位置の直前にスカラー値 x を追加し、追加された要素へのイテレータを返します。 8.3.15 erase(i) このベクトルの i 番目の要素を削除し、削除した直後の要素へのイテレータを返します。 8.3.16 erase(it) イテレータ it で指定された要素を削除し、削除した直後の要素へのイテレータを返します。 8.3.17 erase( first_i, first_i ) first_i 番目 から last_i 番目 までの要素を削除し、削除した直後の要素へのイテレータを返します。 8.3.18 erase( first_it, last_it ) イテレータ first_it と last_it - 1 で指定される範囲の要素を削除し、削除した直後の要素へのイテレータを返します。 8.3.19 containsElementNamed(name) このベクトルが文字列 name で指定された名前の要素を持っている場合には true を返します。 8.4 静的メンバ関数 静的メンバ関数は NumericVector::create() のような形式で呼び出します。 8.4.1 get_na() このベクトルの型に対応した NA 値を返します。 8.4.2 is_na(x) ベクトルの要素 x が NA である場合には true を返します。 8.4.3 create( x1, x2, …) スカラー値 x1, x2, … を要素とするベクトルを作成します。指定できる引数の数は20個まで対応しています。 8.4.4 import( first_it , last_it ) イテレーター first_it, last_it で指定された範囲の値で満たされたベクトルを作成します。 8.4.5 import_transform( first_it, last_it, func) イテレーター first_it, last_it で指定された範囲の値を、func で指定した関数で変換した値で満たされたベクトルを作成します。 "],
["090_matrix.html", "Chapter 9 Matrix 9.1 メンバ関数 9.2 静的メンバ関数 9.3 その他の関数", " Chapter 9 Matrix 9.0.1 作成 ベクトルと同様に、行列もいくつかの方法で作成することができます。 // m &lt;- matrix(0, nrow=2, ncol=2) と同等の行列を作成します NumericMatrix m1( 2 ); // m &lt;- matrix(0, nrow=2, ncol=3) と同等の行列を作成します NumericMatrix m2( 2 , 3 ); // m &lt;- matrix(v, nrow=2, ncol=3) と同等の行列を作成します NumericMatrix m3( 2 , 3 , v.begin() ); また、R における行列の実体は属性 dim に行数と列数が設定されたベクトルですので、Rcpp で作成したベクトルの属性 dim に値を設定し R に返すと行列として扱われます。 // [[Rcpp::export]] NumericVector rcpp_matrix(){ //ベクトルの作成 NumericVector v = {1,2,3,4}; //属性dimに列数、行数をセットします v.attr(&quot;dim&quot;) = Dimension(2, 2); //属性dimをセットしたベクトルをRに返します return v; } 実行結果 &gt; rcpp_matrix() [,1] [,2] [1,] 1 3 [2,] 2 4 ただし、ベクトルの属性 dim に値を設定しても Rcpp での型はベクトル型のままとなります。それを Rcpp の行列型に変換するには as&lt;T&gt;() 関数を用います。 //属性dimに列数、行数をセットします v.attr(&quot;dim&quot;) = Dimension(2, 2); //Rcppの行列型への変換します NumericMatrix m = as&lt;NumericMatrix&gt;(v); 9.0.2 要素へのアクセス () 演算子を用いることで、列番号・行番号をを指定して行列の要素の値を取得、および、行列の要素に値を代入することができます。ベクトルの場合と同様に、行番号や列番号は 0 から始まります。また、行全体、あるいは、列全体にアクセスしたい場合には記号 _ を用います。 また、[] 演算子を使うと行列の列をつなげた１つのベクトルとして要素にアクセスすることができます。 //5行5列の数値行列を作成します NumericMatrix m(5,5); // 0行2列目の要素を取得します double x = m( 0 , 2 ); // 0行目の値をベクトル v にコピーします NumericVector v = m( 0 , _ ); // 2列目の値をベクトル v にコピーします NumericVector v = m( _ , 2 ); // (0〜1)行、(2〜3)列目を行列 m2 にコピーします NumericMatrix m2 = m( Range(0,1) , Range(2,3) ); //行列にベクトルとしてアクセスします m[5]; // これは m(0,1) と同じ要素を指します 9.0.3 行・列・部分行列への参照 Rcppには、一部の列や行への「参照」を保持するオブジェクトも用意されています。 NumericMatrix::Column col = m( _ , 1); //mの1列目の値を参照 NumericMatrix::Row row = m( 1 , _ ); //mの1行目の値を参照 NumericMatrix::Sub sub = m( Range(0,1) , Range(2,3) ); //mの部分行列を参照 m の一部への「参照」オブジェクトに対して値を代入すると、元の行列 m にその値が代入されます。例えば、colへの値の代入は m の列への値の代入することになります。 col = 2*col; // m の 1 列目の値を2倍にすることができる m( _ , 1) = 2*m( _ , 1 ) //上の例と同義 9.1 メンバ関数 Matrix の実体は Vector であるので、Matrix は基本的には Vector と同じメンバ関数を持っています。下には Matrix 固有のメンバ関数を示します。 9.1.1 nrow() rows() 行数を返します。 9.1.2 ncol() cols() 列数を返します。 9.1.3 row( i ) i番目の行への参照 Vector::Row を返します。 9.1.4 column( i ) i番目の列への参照 Vector::Column を返します。 9.1.5 fill_diag( x ) 対角要素をスカラー値 x で満たします。 9.1.6 offset(i,j) i 行 j 列の要素対応する、行列の元ベクトルの要素番号を返します。 9.2 静的メンバ関数 Matrix は基本的には Vector と同じ静的メンバ関数を持っています。以下では Matrix に固有の静的メンバ関数を示します。 9.2.1 Matrix::diag( size, x ) 行数・列数 が size に等しく、対角要素の値が x である対角行列を返します。 9.3 その他の関数 このセクションでは、行列と関連するその他の関数を示します。 9.3.1 rownames( m ) 行列 m の行名の取得と設定をします。 CharacterVector ch = rownames(m); rownames(m) = ch; 9.3.2 colnames( m ) 行列 m の列名の取得と設定をします。 CharacterVector ch = colnames(m); colnames(m) = ch; 9.3.3 transpose( m ) 行列 m の転置行列を返します。 "],
["100_dataframe.html", "Chapter 10 DataFrame 10.1 作成 10.2 要素へのアクセス 10.3 メンバ関数", " Chapter 10 DataFrame 10.1 作成 DataFrame の作成には DataFrame::create() を使用します。また、 DataFrame の作成時にカラム名を指定する場合には、Named(&quot;名前&quot;) または _[&quot;名前&quot;] を使用します。 // Vector v1, v2 から DataFrame df を作成します DataFrame df = DataFrame::create(v1, v2); //列に名前をつける場合 DataFrame df = DataFrame::create(Named(&quot;V1&quot;) = v1 , _[&quot;V2&quot;]=v2); DataFrame::create() で DataFrame を作成すると、カラムには元の Vector の要素の値が複製されるのではなく、元の Vector への「参照」となります。そのため、元の Vector の値を変更すると DataFrame の値も変更されます。そうならないように Vector の要素の値を複製してDataFrame のカラムを作成する場合には clone() 関数を使います。 clone() 関数を使った場合と使わなかった場合の違いを見るために、下のコード例を見てください。コード例では、Vector v からDataFrame df を作成しています。そこでは、カラム V1 は v への参照、カラム V2 は clone() 関数により v の値を複製しています。その後、Vector v に変更操作を行うと、データフレーム df のカラム V1 は変更されていますが、V2 は影響を受けないことがわかります。 // [[Rcpp::export]] DataFrame rcpp_df(){ // ベクトル v を作成します NumericVector v = {1,2}; // データフレムを作成します DataFrame df = DataFrame::create( Named(&quot;V1&quot;) = v, Named(&quot;V2&quot;) = clone(v)); // ベクトル v を変更します v = v*2; return df; } 実行結果 &gt; rcpp_df() V1 V2 1 2 1 2 4 2 10.2 要素へのアクセス DataFrame の特定のカラムにアクセスする場合には、カラムを一旦 Vector に代入し、そのVector を介してアクセスします。ベクトルの要素の指定の場合と同様に、DataFrame のカラムは、数値ベクトル（カラム番号）、文字列ベクトル（カラム名）、論理値ベクトルにより指定できます。 NumericVector v1 = df[0]; NumericVector v2 = df[&quot;V2&quot;]; DataFrame 作成の時と同様に、上の方法で Vector に DataFrame のカラムを代入すると、Vector には カラムの値がコピーされるのではなく、カラムへの「参照」となります。そのため、Vector へ変更操作を行うと、df のカラムの内容も変更されます。 元の DataFrame の値が変更されないようにカラムの値コピーして Vector を作成たい場合には clone() 関数を用います。 NumericVector v1 = df[0]; // v1 は dfの 0 列目への「参照」となります v1 = v1*2; // v1 の値を変更すると df[0] の値も変更されます NumericVector v2 = clone(df[0]); // v2 には df[0] の要素の値を複製します v2 = v2*2; // v2 を変更しても df[0] の値は変わりません 10.3 メンバ関数 Rcpp では、DataFrame や List は、ある種のベクトルとして実装されています。つまり、Vector は、スカラー値を要素とするベクトル、DataFrame は同じ長さの Vector を要素とするベクトルです。そのため、DataFrame は Vector 共通するメンバ関数を多く持っています。 10.3.1 length() size() 列数を返します。 10.3.2 nrows() 行数を返します。 10.3.3 names() カラム名を文字列ベクトルで返します。 10.3.4 offset(name) findName(name) 文字列 name で指定された名前のカラムの列番号を返します。 10.3.5 findName(name) 文字列 name で指定された名前のカラムの列番号を返します。 10.3.6 fill(v) この DataFrame の全てのカラムを Vector v で満たします。 10.3.7 assign( first_it, last_it) イテレーター first_it, last_it で指定された範囲のカラムを、この DataFrame に代入します。 10.3.8 push_back(v) この DataFrame の末尾に Vector v を追加します。 10.3.9 push_back( v, name ) この DataFrame の末尾に Vector v を追加します。 追加したカラムの名前を文字列 name で指定します。 10.3.10 push_front(x) この DataFrame の先頭に Vector v を追加します。 10.3.11 push_front( x, name ) この DataFrame の先頭に Vector v を追加します。追加したカラムの名前を文字列 name で指定します。 10.3.12 begin() この DataFrame の先頭カラムへのイテレータを返します。 10.3.13 end() この DataFrame の末尾へのイテレータを返します。 10.3.14 insert( it, v ) この DataFrame の、イテレータ it で示された位置に`Vector ` v を追加し、その要素へのイテレータを返します。 10.3.15 erase(i) この DataFrame の i 番目のカラムを削除し、削除した直後のカラムへのイテレータを返す。 10.3.16 erase(it) イテレータ it で指定されたカラムを削除し、削除した直後のカラムへのイテレータを返します。 10.3.17 erase(first_i, last_i) first_i 番目 から last_i -1 番目 までのカラムを削除し、削除した直後のカラムへのイテレータを返します。 10.3.18 erase(first_it, last_it) イテレータ first_it から last_it -1 で指定されるカラムまでを削除し、削除した直後のカラムへのイテレータを返します。 10.3.19 containsElementNamed(name) この DataFrame が文字列 name で指定された名前のカラムを持っている場合には true を返します。 10.3.20 inherits(str) このオブジェクトの属性 class に文字列 str が含まれているかどうか。 "],
["110_list.html", "Chapter 11 List 11.1 オブジェクトの作成 11.2 要素へのアクセス 11.3 メンバ関数", " Chapter 11 List List の作成と要素へのアクセスの方法は、基本的には DataFrame の場合と同じです。List が DataFrame と異なる点は、List はその要素として Vector だけではなく S4 や DataFrame や List など任意の型を保持できる点です。 DataFrame のページに記載された内容は、DataFrame を List に置き換えても成立するので、詳細はそちらを参照してください。 11.1 オブジェクトの作成 List の作成には List::create() 関数を使用します。また、List の作成時に要素名を指定する場合には、Named() 関数または _[] を使用します。 List L = List::create(v1, v2); //ベクトル v1, v2 からリスト L を作成します List L = List::create(Named(&quot;名前1&quot;) = v1 , _[&quot;名前2&quot;] = v2); //要素に名前をつける場合 11.2 要素へのアクセス List の特定の要素にアクセスする場合には、リストの要素を ベクトルに代入し、そのベクトルを介してアクセスします。 List の要素は、数値ベクトル、文字列ベクトル、論理ベクトルにより指定できます。 NumericVector v1 = L[0]; NumericVector v2 = L[&quot;V1&quot;]; 11.3 メンバ関数 List も Vector と同じメンバ関数を持っています。 "],
["120_s3_s4.html", "Chapter 12 S3・S4 クラス 12.1 S3クラス 12.2 S4クラス", " Chapter 12 S3・S4 クラス 12.1 S3クラス R の S3 クラスの実体は、オブジェクト属性 class の値に独自の名前が設定されたリストです。 そのため、S3オブジェクトの作成や要素へのアクセスについては List の項を参照してください。 下に S3 のオブジェクトを扱う例として、R の関数lm() の返値を受け取り、学習データにおけるモデルの予測精度の指標として RMSE (Root Mean Square Error; ニ乗平均平方根誤差) を算出する関数の例を示します。 //lm モデルオブジェクトを受け取り RMSE を計算します // [[Rcpp::export]] double rcpp_rmse(List lm_model) { // S3 はリストなので引数の型には List を指定します。 //関数に与えられたオブジェクトが lm() オブジェクトではない場合は //エラーメッセージを出力し実行を停止します。 if (! lm_model.inherits(&quot;lm&quot;)) stop(&quot;Input must be a lm() model object.&quot;); //残差（実測値 - 予測値）を取り出します。 NumericVector resid = lm_model[&quot;residuals&quot;]; //残差の要素数 R_xlen_t n = resid.length(); //残差の平方和 double rmse(0.0); for(double&amp; r : resid){ rmse += r*r; } //残差平方和を要素数で割り、平方根を取る return(sqrt((1.0/n)*rmse)); } 実行例として、R のサンプルデータ mtcars を使って、車の燃費を線形回帰したモデルの RMSE を計算します。 &gt; mod &lt;- lm(mpg ~ ., data = mtcars) &gt; rcpp_rmse(mod) [1] 2.146905 12.2 S4クラス 12.2.1 slot へのアクセス S4 クラスのオブジェクトのスロットへアクセスするには slot() メンバ関数を用います。また、特定の名前のスロットを持っているかどうか確かめるには hasSlot() メンバ関数を用います。 x.slot(&quot;スロット名&quot;); x.hasSlot(&quot;スロット名&quot;); 12.2.2 新しい S4 クラスのオブジェクトを作成する Rcpp 単体では新しい S4 クラスを定義することができないですが、 R で定義した S4 クラスのオブジェクトを Rcpp で作成することはできます。 次ののコード例では、R で新しい S4 クラス Person を定義して、その後、Rcpp で Person クラスのオブジェクトを作成する例を示します。 まずは S4 クラスの Person を定義します。このクラスは、スロットとして、名前を表す name、誕生日を表す birth を保持しています。 # R で S4クラス Person を定義します setClass ( # クラス名 &quot;Person&quot;, # スロットの型を指定 representation ( name = &quot;character&quot;, birth = &quot;Date&quot; ), # スロットの初期化 prototype = list( name = as.character(NULL), birth = as.Date(as.character(NULL)) ) ) # R で Person クラスのオブジェクトを作成する例 person_01 &lt;- new(&quot;Person&quot;, name = &quot;Ronald Fisher&quot;, birth = as.Date(&quot;1890-02-17&quot;)) 次に Rcpp で Person クラスのオブジェクトを作成し、そのスロットに値を設定します。 // [[Rcpp::export]] S4 rcpp_s4(){ // Person クラスのオブジェクトを作成します S4 x(&quot;Person&quot;); // スロットに値を設定します x.slot(&quot;name&quot;) = &quot;Sewall Wright&quot;; x.slot(&quot;birth&quot;) = Date(&quot;1889-12-21&quot;); return(x); } 実行結果 &gt; rcpp_s4() An object of class &quot;Person&quot; Slot &quot;name&quot;: [1] &quot;Sewall Wright&quot; Slot &quot;birth&quot;: [1] &quot;1889-12-21&quot; "],
["130_string.html", "Chapter 13 String 13.1 String オブジェクトの作成 13.2 演算子 13.3 メンバ関数", " Chapter 13 String String は、CharacterVector の要素に対応するスカラー型です。String は C の文字列 char* や C++ の文字列 std::string では対応していない NA 値（NA_STRING）も扱うことができます。 13.1 String オブジェクトの作成 String 型のオブジェクトの作成方法には、大別して、C/C++の文字列から作成する方法、別の String オブジェクトから作成する方法、長さが文字列ベクトルの１つの要素から作成する方法、の3通りの方法があります。また、文字コードも合わせて指定することができます。 //文字列を指定する String s; // &quot;&quot; String s(&quot;X&quot;); // &quot;X&quot; //String 型の文字列 str の値をコピーして作成する String s(str); String s(str, &quot;UTF-8&quot;); //encodingも指定する //文字列ベクトル char_vec の１つの要素の値をコピーして作成する String s(char_vec[0]) String s(char_vec[0], &quot;UTF-8&quot;) //encodingを指定する 13.2 演算子 String には += 演算子が定義されています。これにより文字列の末尾に別の文字列を結合できます。 （ + 演算子は定義されてないので注意してください） // String オブジェクトの作成 String s(&quot;A&quot;); // 文字列を結合します s += &quot;B&quot;; Rcout &lt;&lt; s &lt;&lt; &quot;\\n&quot;; //&quot;AB&quot; 13.3 メンバ関数 注：メンバ関数 replace_first(), replace_last(), replace_all() は単に文字を置き換えた文字列を返すわけではなく、このオブジェクトの値をそのものを書き換えます。 13.3.1 replace_first( str, new_str) この String オブジェクトの中で文字列 str と一致する最初に見つけた部分文字列を文字列 new_str に置き換えます。 13.3.2 replace_last( str, new_str) この String オブジェクトの中で、文字列 str と一致する最後に見つけた部分文字列 str を 文字列 new_str に置き換えます。 13.3.3 replace_all( str, new_str) この String オブジェクトの中で、文字列 str と一致する全ての部分文字列 str を 文字列 new_str に置き換えます。 13.3.4 push_back(str) この String オブジェクトの末尾に文字列 str を結合します。（ += 演算子と同じ機能） 13.3.5 push_back(str) この String オブジェクトの先頭に文字列 str を結合します。 13.3.6 set_na() NA 値をセットします。 13.3.7 get_cstring() String オブジェクトの文字列を C 言語の文字列定数（const char*）に変換して返します。 13.3.8 get_encoding() 文字コード（“bytes”, “latin1”, “UTF-8”, “unknown”のいずれか）を返します。 13.3.9 set_encoding(str) 文字列 str で指定する文字コード設定します。 13.3.10 コード例 以下のコードでは、“abcdabcd” という文字列に対して、“ab” を “AB” に置換する処理を以下の3通りの方法で実行しています。 (1) “ab” が初めて出現する箇所でのみ置換 (replace_first() メンバ関数) (2) “ab” が最後に出現する箇所でのみ置換 (replace_last() メンバ関数) (3) “ab” が出現するすべての箇所で置換 (replace_all() メンバ関数) なお、メンバ関数 replace_first(), replace_last(), replace_all() は単に文字を置き換えた文字列を返すわけではなく、このオブジェクトの値をそのものを書き換えます。 // [[Rcpp::export]] void rcpp_replace(){ //&quot;ab&quot; が初めて出現する箇所でのみ置換します String s(&quot;abcdabcd&quot;); s.replace_first(&quot;ab&quot;, &quot;AB&quot;); Rcout &lt;&lt; s.get_cstring() &lt;&lt; &quot;\\n&quot;; // ABcdabcd //&quot;ab&quot; が最後に出現する箇所でのみ置換します s=&quot;abcdabcd&quot;; s.replace_last(&quot;ab&quot;, &quot;AB&quot;); Rcout &lt;&lt; s.get_cstring() &lt;&lt; &quot;\\n&quot;; // abcdABcd //&quot;ab&quot; が出現するすべての箇所で置換します s=&quot;abcdabcd&quot;; s.replace_all(&quot;ab&quot;, &quot;AB&quot;); Rcout &lt;&lt; s.get_cstring() &lt;&lt; &quot;\\n&quot;; // ABcdABcd } 実行結果 &gt; rcpp_string() ABcdabcd ABcdabcd abcdaABd ABcdABcd "],
["140_date.html", "Chapter 14 Date 14.1 作成 14.2 演算子 14.3 メンバ関数 14.4 実行例", " Chapter 14 Date Date は、DateVector の要素となる、スカラー型です。 14.1 作成 Date d; //&quot;1970-01-01&quot; Date d(1); //&quot;1970-01-01&quot; + 1day Date d(1.1); //&quot;1970-01-01&quot; + ceil(1.1)day Date( &quot;2000-01-01&quot;, &quot;%Y-%m-%d&quot;); //default format is &quot;%Y-%m-%d&quot; Date( 1, 2, 2000); // 2000-01-02 Date(mon, day, year) Date( 2000, 1, 2); // 2000-01-02 Date(year, mon, day) 14.2 演算子 Date には + - &lt; &gt; &gt;= &lt;= == != の演算子が定義されています。これらの演算子を用いることにより、日数の加算(+)、日数の差分計算(-)、日付の比較(&lt;, &lt;=, &gt;, &gt;=, ==, !=) を行えるようになります。 + - &lt; &gt; &gt;= &lt;= == != // [[Rcpp::export]] DateVector rcpp_date1(){ // Date の作成 Date d1(&quot;2000-01-01&quot;); Date d2(&quot;2000-02-01&quot;); int i = d2 - d1; //日付の差（日） bool b = d2 &gt; d1; //日付の比較 Rcout &lt;&lt; i &lt;&lt; &quot;\\n&quot;; // 31 Rcout &lt;&lt; b &lt;&lt; &quot;\\n&quot;; // 1 // d1 に 1 日加算した結果を日付ベクトルに代入します。 DateVector date(1); date[0] = d1 + 1; return date; // 2000-01-02 } 14.3 メンバ関数 14.3.1 getDay() 日付の日を返します。 14.3.2 getMonth() 日付のの月を返します。 14.3.3 getYear() 日付の年を返します。 14.3.4 getWeekday() 日付の曜日を int で返します。返値は 1=Sun 2=Mon 3=Tue 4=Wed 5=Thu 6=Sat に対応します。 14.3.5 getYearday() 1月1日を 1 、12月31日を 365 とした年間を通した日付の番号を返します。 14.3.6 is_na() このオブジェクトが NA であるなら true を返します。 14.4 実行例 Date d(&quot;2016-1-1&quot;); Rcout &lt;&lt; d.getDay() &lt;&lt; endl; //1 Rcout &lt;&lt; d.getMonth() &lt;&lt; endl; //1 Rcout &lt;&lt; d.getYear() &lt;&lt; endl; //2016 Rcout &lt;&lt; d.getWeekday() &lt;&lt; endl; //6 Rcout &lt;&lt; d.getYearday() &lt;&lt; endl; //1 "],
["150_datetime.html", "Chapter 15 Datetime 15.1 Datetime オブジェクトの作成 15.2 タイムゾーン 15.3 演算子 15.4 メンバ関数 15.5 コード例", " Chapter 15 Datetime Datetime は DatetimeVector の要素に対応するスカラー型です。 15.1 Datetime オブジェクトの作成 Date と同様に、Datetime の作成方法も、世界協定時（UTC）の 1970-01-01 00:00:00 からの秒数を指定して作成する方法と、明示的に日時を指定して作成する方法があります。 明示的に日時を指定して作成する形式は Datetime dt( str, format) となります。この形式では書式文字列 format を指定して文字列 str を Datetime に変換します。(formatで使用する記号は R の help(strptime) を参照してください） // 1970年1月1日 00:00:00 からの経過秒数（実数）で作成します Datetime dt; // &quot;1970-01-01 00:00:00 UTC&quot; Datetime dt(10.1); // &quot;1970-01-01 00:00:00 UTC&quot; + 10.1sec // 日時・時間と書式を指定して作成します // デフォルトの書式は &quot;%Y-%m-%d %H:%M:%OS&quot; です // 指定した日時はローカルなタイムゾーンの日時として解釈されます Datetime dt(&quot;2000-01-01 00:00:00&quot;); Datetime dt(&quot;2000年1月1日 0時0分0秒&quot;, &quot;%Y年%m月%d日 %H時%M分%OS秒&quot;); 15.2 タイムゾーン Datetime は、内部的には日時を協定世界時 (UTC) 1970-01-01 00:00:00 からの秒数（実数）で管理しています。例えば Datetime dt(10) は世界協定時 1970-01-01 00:00:00 UTC から10秒経過後の時点を表します。この値を R に返すと実行されたタイムゾーンに変換された時刻として表示されます。例えば日本なら日本標準時（JST）は UTC + 9時間なので、Datetime(10) は 1970-01-01 09:00:10 JST となります。 この形式では、str はローカルなタイムゾーンの時刻として解釈されます。例えば日本標準時（JST）で、Datetime(&quot;2000-01-01 00:00:00&quot;) を実行すると、内部的には 1999-12-31 15:00:00 UTC の値がセットされます。 15.3 演算子 Datetime には + - &lt; &gt; &gt;= &lt;= == != の演算子が定義されています。 これらの演算子を用いることにより、秒数の加算 (+)、日時の差分(-)、日時の比較(&lt;, &lt;=, &gt;, &gt;=, ==, !=) を行えるようになります。日時に加算する値と、日時の差分の返値の単位は秒となります。 Datetime dt1(&quot;2000-01-01 00:00:00&quot;); Datetime dt2(&quot;2000-01-02 00:00:00&quot;); //日時の差分（秒） int sec = dt2 - dt1; // 86400 //日時に秒数を加算 dt1 = dt1 + 1; // &quot;2000-01-01 00:00:01&quot; //日時の比較 bool b = dt2 &gt; dt1; // true 15.4 メンバ関数 注意：これらのメンバ関数を使って出力される時刻の値は、世界協定時で解釈した時刻の値になっています。そのため、ユーザーのタイムゾーンの日時とは異なって見えます。（出力結果はこの章の末尾に記載したのコードの実行結果を参照してください） 15.4.1 getFractionalTimestamp() 世界協定時の基準日（1970-01-01 00:00:00 UTC）からの秒数（実数値）を返します 15.4.2 getMicroSeconds() 世界協定時の日時のマイクロ秒を返します。これは秒の小数点以下の値を 1/1000000 秒単位で表記した値です。（0.1 秒 = 100000 マイクロ秒） 15.4.3 getSeconds() 世界協定時の日時の秒を返します。 15.4.4 getMinutes() 世界協定時の日時の分を返します。 15.4.5 getHours() 世界協定時の日時の時を返します。 15.4.6 getDay() 世界協定時の日時の日を返します。 15.4.7 getMonth() 世界協定時の日時の月を返します。 15.4.8 getYear() 世界協定時の日時の年を返します。 15.4.9 getWeekday() 世界協定時の曜日 世界協定時の日時の曜日を int で返します。1=Sun 2=Mon 3=Tue 4=Wed 5=Thu 6=Sat 15.4.10 getYearday() 1月1日を 1 、12月31日を 365 とした年間を通した日付の番号を返します。 15.4.11 is_na() このオブジェクトが NA である場合には true を返します。 15.5 コード例 以下のコード例では、日本標準時（JST）の環境で実行した結果を示します。 // [[Rcpp::export]] Datetime rcpp_datetime(){ // 日時を指定して Datetime オブジェクトを作成する Datetime dt(&quot;2000-01-01 00:00:00&quot;); // 日時の要素を世界協定時で表示します Rcout &lt;&lt; &quot;getYear &quot; &lt;&lt; dt.getYear() &lt;&lt; &quot;\\n&quot;; Rcout &lt;&lt; &quot;getMonth &quot; &lt;&lt; dt.getMonth() &lt;&lt; &quot;\\n&quot;; Rcout &lt;&lt; &quot;getDay &quot; &lt;&lt; dt.getDay() &lt;&lt; &quot;\\n&quot;; Rcout &lt;&lt; &quot;getHours &quot; &lt;&lt; dt.getHours() &lt;&lt; &quot;\\n&quot;; Rcout &lt;&lt; &quot;getMinutes &quot; &lt;&lt; dt.getMinutes() &lt;&lt; &quot;\\n&quot;; Rcout &lt;&lt; &quot;getSeconds &quot; &lt;&lt; dt.getSeconds() &lt;&lt; &quot;\\n&quot;; Rcout &lt;&lt; &quot;getMicroSeconds &quot; &lt;&lt; dt.getMicroSeconds() &lt;&lt; &quot;\\n&quot;; Rcout &lt;&lt; &quot;getWeekday &quot; &lt;&lt; dt.getWeekday() &lt;&lt; &quot;\\n&quot;; Rcout &lt;&lt; &quot;getYearday &quot; &lt;&lt; dt.getYearday() &lt;&lt; &quot;\\n&quot;; Rcout &lt;&lt; &quot;getFractionalTimestamp &quot; &lt;&lt; dt.getFractionalTimestamp() &lt;&lt; &quot;\\n&quot;; return dt; } 実行結果 出力される世界協定時（UTC）は日本標準時（JST）から9時間前の日時となっていることがわかります。 &gt; rcpp_datetime() getYear 1999 getMonth 12 getDay 31 getHours 15 getMinutes 0 getSeconds 0 getMicroSeconds 0 getWeekday 6 getYearday 365 getFractionalTimestamp 9.46652e+08 [1] &quot;2000-01-01 JST&quot; "],
["160_robject.html", "Chapter 16 RObject 16.1 メンバー関数 16.2 A.20.2 RObject を利用した型の判別", " Chapter 16 RObject RObject 型は Rcpp で定義されたどのような型のオブジェクトでも代入することができる型です。変数にどのような型が渡されるか実行時にならないとわからない場合には、RObject を用いると良いでしょう。 16.1 メンバー関数 RObject は以下のメンバー関数を持ちます。これらのメンバー関数は Rcpp が提供する、他の全ての API クラス（Vectorなど）でも同じものを共通して持っています。 16.1.1 inherits(str) このオブジェクトが文字列 str で指定したクラスを継承している場合は true を返します。 16.1.2 slot(name) このオブジェクトが S4 の場合、文字列 name で指定したスロットにアクセスします。 16.1.3 hasSlot(name) このオブジェクトが S4 の場合、文字列 name で指定したスロットがある場合は true を返します。 16.1.4 attr(name) このオブジェクトの文字列 name で指定した属性にアクセスします。 16.1.5 attributeNames() このオブジェクトが持つ全ての属性の名前を std::vector&lt;std::string&gt; 型で返します。 16.1.6 hasAttribute(name) このオブジェクトが文字列 name で指定した名前の属性を持っている場合は true を返します。 16.1.7 isNULL() このオブジェクトが NULL である場合は true を返します。 16.1.8 sexp_type() このオブジェクトの SXPTYPE を int 型で返します。 R で定義された全てのSEXPTYPEのリストはRのマニュアルを参照してください。 16.1.9 isObject() このオブジェクトが “class” 属性を持っている場合には true を返します。 16.1.10 isS4() このオブジェクトが S4 オブジェクトである場合には true を返します。 16.2 A.20.2 RObject を利用した型の判別 RObject の使い方の１つとして、オブジェクトの型の判別があります。RObject に代入された値が実際にはどの型であるのか判別するには、is&lt;T&gt;() 関数やメンバ関数の isS4() isNULL() を用います。 ただし、行列や因子ベクトルはベクトルに特定の属性値が設定されたものなので is&lt;T&gt;() 関数だけでは判定できません。それらを判定する場合には Rf_isMatrix() 関数や Rf_isFactor() 関数を用います。 下のコード例では、RObject を利用した型の判別の方法を示します。 // [[Rcpp::export]] void rcpp_type(RObject x){ if(is&lt;NumericVector&gt;(x)){ if(Rf_isMatrix(x)) Rcout &lt;&lt; &quot;NumericMatrix\\n&quot;; else Rcout &lt;&lt; &quot;NumericVector\\n&quot;; } else if(is&lt;IntegerVector&gt;(x)){ if(Rf_isFactor(x)) Rcout &lt;&lt; &quot;factor\\n&quot;; else Rcout &lt;&lt; &quot;IntegerVector\\n&quot;; } else if(is&lt;CharacterVector&gt;(x)) Rcout &lt;&lt; &quot;CharacterVector\\n&quot;; else if(is&lt;LogicalVector&gt;(x)) Rcout &lt;&lt; &quot;LogicalVector\\n&quot;; else if(is&lt;DataFrame&gt;(x)) Rcout &lt;&lt; &quot;DataFrame\\n&quot;; else if(is&lt;List&gt;(x)) Rcout &lt;&lt; &quot;List\\n&quot;; else if(x.isS4()) Rcout &lt;&lt; &quot;S4\\n&quot;; else if(x.isNULL()) Rcout &lt;&lt; &quot;NULL\\n&quot;; else Rcout &lt;&lt; &quot;unknown\\n&quot;; } 型の判定をした後に RObject を別の Rcpp 型に変換するには as&lt;T&gt;() を用います。 // RObject を NumericVector に変換します RObject x; NumericVector v = as&lt;NumericVector&gt;(x); "],
["161_notification_vector.html", "Chapter 17 Rのオブジェクトを扱う際の注意点 17.1 ベクトル同士の代入 17.2 要素番号の型 17.3 []演算子の返値", " Chapter 17 Rのオブジェクトを扱う際の注意点 ベクトル同士の代入 要素番号の型 []演算子の返値 17.1 ベクトル同士の代入 ベクトルや行列同士で代入する際に、単純に v2 = v1 で代入すると v1 の要素の値が v2 にコピーされるのではなく、v1 と v2 は同じオブジェクトに対する別名となります。そのため v1 の値を変更すると v2 の値も変更されてしまいます。それを避けるためには clone() 関数を使用します。すると v1 の値を変更しても、v2 の値は変更されません。 C++ に詳しい人のために説明すると、Rcpp のデータ型は内部にオブジェクトの値そのものではなく、オブジェクトへのポインタを保持しています。そのため、単純に v2 = v1 で代入すると v1 が指し示すオブジェクトへのポインターの値がコピーされるので v1 と v2 は同じオブジェクトを指し示す結果となります。これをシャロー（浅い）コピーと呼びます。それに対して、v2 = clone(v1) を用いた場合には、v1 が持つポインタが指し示すオブジェクトの値を複製して、新たに別のオブジェクトを作成します。これをディープ（深い）コピーと呼びます。 下のコード例では、浅いコピーと深いコピーの後に代入した元のベクトルの値を変更した時の結果の違いを示します。 NumericVector v1 = {1,2,3}; NumericVector v2 = v1; // v2 は単純な代入（浅いコピー） NumericVector v3 = clone(v1); // v3 は clone() で代入（深いコピー） v1[0] = 100; // v1 の値を変更します // 値を確認すると v2 には v1 への変更が影響していますが // v3 には影響していないことがわかります Rcout &lt;&lt; &quot;v1 = &quot; &lt;&lt; v1 &lt;&lt; endl; // 100 2 3 Rcout &lt;&lt; &quot;v2 = &quot; &lt;&lt; v2 &lt;&lt; endl; // 100 2 3 Rcout &lt;&lt; &quot;v3 = &quot; &lt;&lt; v3 &lt;&lt; endl; // 1 2 3 C++に詳しい人のために説明すると、Rcppのデータ型は内部にオブジェクトの値そのものではなく、オブジェクトへのポインタを保持しています。そのため、単純に v2 = v1 で代入するとすると内部のポインターの値がコピーされてしまうので、このような現象が起きる。 17.2 要素番号の型 32 bit システムやバージョン 2 以前の R ではベクトルの要素番号には int 型が使われていたため、ベクトルの要素数の最大値は 2^31 - 1 となっていました。しかし、現在一般的となっている 64 bit システムにおけるバージョン3以降のRではこれよりも要素数の大きいベクトル（Long Vector）を扱うことができます。Rcpp で Long Vector をサポートするためには、要素数や要素番号を変数として保持する場合に int 型ではなく R_xlen_t 型を用います。64 bit システムでも要素番号として int 型を用いることもできますが、その場合には長さが 2^31 - 1 を超えるベクトルを渡された時に処理ができなくなります。 // 要素数 n を R_xlen_t 型として宣言する R_xlen_t n = v.length(); double sum = 0; // 要素番号 i を R_xlen_t 型として宣言する for(R_xlen_t i=0; i&lt;n; ++i){ sum += v[i]; } 17.3 []演算子の返値 [] や () 演算子でベクトルの要素へアクセスした時の返値は、Vectorそのものではなく Vector::Proxy という型となっています。そのため、v[] を他の関数の引数として与えるとコンパイルエラーになることがあります。その場合には、as&lt;T&gt;() を用いて、目的の型 T (NumericVector など) に変換します。 NumericVector v {1,2,3,4,5}; IntegerVector i {1,3}; // これはコンパイルエラーとなる //double x1 = sum(v[i]); // 変数として保持する NumericVector vi = v[i]; double x2 = sum(vi); // as&lt;T&gt;() で変換する double x3 = sum(as&lt;NumericVector&gt;(v[i])); "],
["170_calculation.html", "Chapter 18 四則演算と比較演算 18.1 四則演算 18.2 比較演算", " Chapter 18 四則演算と比較演算 18.1 四則演算 R と同様に、+ - * / 演算子により、同じ長さのベクターの要素同士の四則演算を行うことができます。 NumericVector x ; NumericVector y ; // ベクトルとベクトルの演算 NumericVector res = x + y ; NumericVector res = x - y ; NumericVector res = x * y ; NumericVector res = x / y ; // ベクトルとスカラーの演算 NumericVector res = x + 2.0 ; NumericVector res = 2.0 - x; NumericVector res = y * 2.0 ; NumericVector res = 2.0 / y; // 演算式と演算式の演算 NumericVector res = x * y + y / 2.0 ; NumericVector res = x * ( y - 2.0 ) ; NumericVector res = x / ( y * y ) ; また - 演算子は符号を反転します。 NumericVector res = -x ; 18.2 比較演算 Rと同様に、== != &lt; &gt;``&gt;= &lt;=演算子を用いたベクトル同士の値は論理ベクトルを生成します。また、論理ベクターを使って、ベクターの要素にアクセスすることもできます。 NumericVector x ; NumericVector y ; // ベクトルとベクトルの比較 LogicalVector res = x &lt; y ; LogicalVector res = x &gt; y ; LogicalVector res = x &lt;= y ; LogicalVector res = x &gt;= y ; LogicalVector res = x == y ; LogicalVector res = x != y ; // ベクトルとスカラーの比較 LogicalVector res = x &lt; 2 ; LogicalVector res = 2 &gt; x; LogicalVector res = y &lt;= 2 ; LogicalVector res = 2 != y; // 演算式と演算式の比較 LogicalVector res = ( x + y ) &lt; ( x*x ) ; LogicalVector res = ( x + y ) &gt;= ( x*x ) ; LogicalVector res = ( x + y ) == ( x*x ) ; また、! 演算子は論理値を反転します。 LogicalVector res = ! ( x &lt; y ); 論理値ベクターを使ってベクターの要素にアクセスします。 NumericVector res = x[x &lt; 2]; "],
["180_logical.html", "Chapter 19 論理演算 19.1 LogicalVector の正体 19.2 論理演算 19.3 LogicalVector を受け取る関数 19.4 LogicalVector の要素の評価", " Chapter 19 論理演算 19.1 LogicalVector の正体 C++ の論理値型は bool であるので、LogicalVector の要素の型も bool であると思うかもしれないが、実際には int 型です。(R でも論理ベクトルの実体は整数ベクトルである) なぜこのようになっているかというと bool で表現できるのは true と false の２つだけですが、R の論理ベクトルの要素の値には TRUE, FALSE,NA の３つがあり得るためです。 Rcpp では TRUE は 1、FALSE は 0、NA は NA_LOGICAL（int の最小値）で表現されています。 logical Rcppの記号 int bool TRUE TRUE 1 (0以外の値) true FALSE FALSE 0 false NA NA_LOGICAL int の最小値 true 19.2 論理演算 LogicalVector の要素ごとの論理演算には演算子 &amp;（論理積） |（論理和） !（論理否定）を用います。 LogicalVector v1 = {1,1,0,0}; LogicalVector v2 = {1,0,1,0}; LogicalVector res1 = v1 &amp; v2; LogicalVector res2 = v1 | v2; LogicalVector res3 = !(v1 | v2); Rcout &lt;&lt; res1 &lt;&lt; &quot;\\n&quot;; // 1 0 0 0 Rcout &lt;&lt; res2 &lt;&lt; &quot;\\n&quot;; // 1 1 1 0 Rcout &lt;&lt; res3 &lt;&lt; &quot;\\n&quot;; // 0 0 0 1 19.3 LogicalVector を受け取る関数 LogicalVector を受け取る関数には all() any() ifelse() があります。 19.3.1 all() と any() LogicalVector v に対して、all(v) は、v の全ての要素が TRUE の時 TRUE を返します。any(v) は、v のいずれかのの要素が TRUE の時、TRUEを返します。 all() 関数や any() 関数の返値を if 文の条件式としてそのまま用いることはできません。これは all() 関数と any() 関数の返値の型は SingleLogicalResult という型になっているためです。all() 関数や any() 関数の返値を if 文の条件式として用いるためには関数 is_true() is_false() is_na() を使って返値を bool 型に変換します。 下のコード例では、関数 all() と any() の返値を if 文の条件式として使うときの方法を示します。この例では、全ての if 文の条件式は真となります、そして、all(), any() の返値を表示します。 // [[Rcpp::export]] List rcpp_logical_03(){ LogicalVector v1 = LogicalVector::create(1,1,1,NA_LOGICAL); LogicalVector v2 = LogicalVector::create(0,1,0,NA_LOGICAL); // NA を含む LogicalVector に対する all(), any() の挙動は R と同じです LogicalVector lv1 = all( v1 ); // NA LogicalVector lv2 = all( v2 ); // FALSE LogicalVector lv3 = any( v2 ); // TRUE // bool に代入する場合 bool b1 = is_true ( all(v1) ); // false bool b2 = is_false( all(v1) ); // false bool b3 = is_na ( all(v1) ); // true // if 文の条件式で用いる場合 if(is_na(all( v1 ))) { // OK Rcout &lt;&lt; &quot;all( v1 ) is NA\\n&quot;; } return List::create(lv1, lv2, lv3, b1, b2, b3); } 19.3.2 ifelse() ifelse(v, x1, x2) は論理ベクター v を受け取り、v の要素が TRUE の時には x1 の対応する要素を, FALSE の時には x2 の対応する要素を返します。 x1, x2 はベクターでもスカラーでも良いですが、ベクターの場合にはその長さは v と一致している必要があります。 NumericVector v1; NumericVector v2; //ベクトルの要素数 int n = v1.length(); // x1, x2 が スカラー, スカラーの場合 IntegerVector res1 = ifelse( v1&gt;v2, 1, 0); NumericVector res2 = ifelse( v1&gt;v2, 1.0, 0.0); //CharacterVector res3 = ifelse( v1&gt;v2, &quot;T&quot;, &quot;F&quot;); // 対応していない // ifelse()が文字列スカラーには対応していないので // 同等の結果を得るためには要素の値が全て同じである文字列ベクトルを用います CharacterVector chr_v1 = rep(CharacterVector(&quot;T&quot;), n); CharacterVector chr_v2 = rep(CharacterVector(&quot;F&quot;), n); CharacterVector res3 = ifelse( v1&gt;v2, chr_v1, chr_v2); // x1, x2 が ベクトル, スカラーの場合 IntegerVector int_v1, int_v2; NumericVector num_v1, num_v2; IntegerVector res4 = ifelse( v1&gt;v2, int_v1, 0); NumericVector res5 = ifelse( v1&gt;v2, num_v1, 0.0); CharacterVector res6 = ifelse( v1&gt;v2, chr_v1, Rf_mkChar(&quot;F&quot;)); //（注） // x1, x2 が ベクトル, ベクトルの場合 IntegerVector res7 = ifelse( v1&gt;v2, int_v1, int_v2); NumericVector res8 = ifelse( v1&gt;v2, num_v1, num_v2); CharacterVector res9 = ifelse( v1&gt;v2, chr_v1, chr_v2); （注）：Rf_mkChar() はC言語の文字列型 (char*) を CHARSXP （CharacterVector の要素の型）に変換する関数です。 19.4 LogicalVector の要素の評価 LogicalVector の要素の値を、そのまま if 文の条件式として使用してはいけません。なぜなら、C++ の if 文の条件式は式の値をbool 型として評価するのですが、 bool 型は 0 以外の値を全て true と評価するので、LogicalVector の NA（NA_LOGICAL） は true と評価されてしまうためです。 LogicalVector の要素の値を if 文で評価する方法については、次のコード例を参考にしてください。 // [[Rcpp::export]] LogicalVector rcpp_logical(){ // NA を含む整数ベクトルを作成します IntegerVector x = {1,2,3,4,NA_INTEGER}; // 比較演算の結果は LogicalVector となります LogicalVector v = (x &gt;= 3); // LogicalVector の要素を直接 if 文の条件式で使うと // NA_LOGICAL は TRUE と評価されてしまいます for(int i=0; i&lt;v.size();++i) { if(v[i]) Rprintf(&quot;v[%i] is evaluated as true.\\n&quot;,i); else Rprintf(&quot;v[%i] is evaluated as false.\\n&quot;,i); } // LogicalVector の要素の評価します for(int i=0; i&lt;v.size();++i) { if(v[i]==TRUE) Rprintf(&quot;v[%i] is TRUE.\\n&quot;,i); else if (v[i]==FALSE) Rprintf(&quot;v[%i] is FALSE.\\n&quot;,i); else if (v[i]==NA_LOGICAL) Rprintf(&quot;v[%i] is NA.\\n&quot;,i); else Rcout &lt;&lt; &quot;v[&quot; &lt;&lt; i &lt;&lt; &quot;] is not 1\\n&quot;; } // TRUE FALSE NA_LOGICAL の値を表示します Rcout &lt;&lt; &quot;TRUE &quot; &lt;&lt; TRUE &lt;&lt; &quot;\\n&quot;; Rcout &lt;&lt; &quot;FALSE &quot; &lt;&lt; FALSE &lt;&lt; &quot;\\n&quot;; Rcout &lt;&lt; &quot;NA_LOGICAL &quot; &lt;&lt; NA_LOGICAL &lt;&lt; &quot;\\n&quot;; return v; } 実行結果 &gt; rcpp_logical() v[0] is evaluated as false. v[1] is evaluated as false. v[2] is evaluated as true. v[3] is evaluated as true. v[4] is evaluated as true. v[0] is FALSE. v[1] is FALSE. v[2] is TRUE. v[3] is TRUE. v[4] is NA. TRUE 1 FALSE 0 NA_LOGICAL -2147483648 [1] FALSE FALSE TRUE TRUE NA "],
["200_rcpp_functions.html", "Chapter 20 R ライクな関数 20.1 Rライクな関数の一覧", " Chapter 20 R ライクな関数 R の関数と類似した Rcpp の関数の一覧を示します。 また、これらの関数に与えるベクトルに NA が含まれていないと保証できる場合には、noNA()を使って印をつけると Rcpp 関数が NA のチェックを行わなくなるので計算が速くなる場合があります。 NumericVector res = mean(noNA(v)); 20.1 Rライクな関数の一覧 ベクトルに関連する関数 文字列に関連する関数 値の検索に関連する関数 重複の値に関連する関数 集合演算に関連する関数 最大値・最小値に関連する関数 集計に関連する関数 端数処理に関連する関数 数学に関連する関数 論理値に関連する関数 NA、Inf、NaNに関連する関数 apply関数 cbind関数 20.1.1 ベクトルに関連する関数 head(v, n) ベクトル v の最初の要素から n 個のベクトルを返す。 tail(v, n) ベクトル v の最後の要素から n 個のベクトルを返す。 rev(v) ベクトル v の要素を逆順に並べたベクトルを返す。 rep(x, n) ベクトルあるいはスカラー x を n 個つなげたベクトルを返す。 rep_each(v, times) ベクトル v の要素を順に times 回ずつ繰り返したベクトルを返す。 rep_len(v, n) 最終的にベクトルの長さが n になるまでベクトル v を繰り返したベクトルを返す。 seq(start, end) 整数 start から end までの連続した整数のベクトルを返す。 seq_along(v) 1 からベクトル v の要素数までの連続した整数のベクトルを返す seq_len(n) 1 から n までの連続した整数のベクトルを返す diff(v) ベクトル v の最後の要素を除いた各要素 i について v[i+1] - v[i] を計算したベクトルを返す。 20.1.2 文字列に関連する関数 collapse(v) 文字列ベクトル v の各要素を結合した文字列を String 型で返す。 20.1.3 値の検索に関連する関数 match(v, table) ベクトル v の各要素について、値が一致するベクトル table の最初の要素の要素番号（1から始まる）を格納した整数ベクトルを返す。（つまり、res = match(v, table) とすると、res[i] には v[i]==table[j] となる最小の j+1 の値が格納される） self_match(v) match(v, table) の v と table に同じベクトルを渡した場合と同義。 which_max(v) ベクトル v の最大の要素の要素番号を返す。 which_min(v) ベクトル v の最小の要素の要素番号を返す。 20.1.4 重複の値に関連する関数 duplicated(v) ベクトル v の各要素の値が、それより前の要素に存在する場合には 1 を、そうでない場合には 0 を入れたベクトルを返す。 unique(v) ベクトル v から要素の値の重複をなくしたベクトルを返す。 sort_unique(v) ベクトル v から要素の値の重複をなくし、値を昇順でソートしたベクトルを返す。 20.1.5 集合演算に関連する関数 setdiff(v1,v2) ベクトル v1 のユニークな(値の重複のない)要素から、ベクトル v2 のユニークな要素にある値を除いたベクトルを返す。 setequal(v1,v2) ベクトル v1 のユニークな要素がベクトル v2 のユニークな要素と等しい場合には true を返す。 intersect(v1,v2) ベクトル v1 のユニークな要素とベクトル v2 のユニークな要素の両方に含まれる要素をベクトルで返す。 union_(v1,v2) ベクトル v1 とベクトル v2 の要素を合わせてから値の重複をなくしたベクトルを返す。 20.1.6 最大値・最小値に関連する関数 min(v) ベクトル v の要素の最小値を返す。 max(v) ベクトル v の要素の最大値を返す。 cummin(v) ベクトル v の各要素について、その要素自身を含むそれ以前の要素の最小値を格納したベクトルを返す cummax(v) ベクトル v の各要素について、その要素自身を含むそれ以前の要素の最大値を格納したベクトルを返す pmin(v1,v2) ベクトル v1 v2 の対応する要素を比較し、大さい方の要素を格納したベクトルを返す。 pmax(v1,v2) ベクトル v1 v2 の対応する要素を比較し、大きい方の要素を格納したベクトルを返す。 range(v) ベクトル v の最小値と最大値からなるベクトルを返す。 clamp(min, v, max) ベクトル v の要素の min 未満の値を min に、max 超の値を max に置き換えたベクトルを返す。 20.1.7 集計に関連する関数 sum(v) ベクトル v の要素の値の総和を返す。 mean(v) ベクトル v の要素の値の平均値を返す。 median(v) ベクトル v の要素の値の中央値を返す。 sd(v) ベクトル v の要素の値の標準偏差を返す。 var(v) ベクトル v の要素の値の分散を返す。 cumsum(v) ベクトル v の各要素について、それ以前の要素の総和を格納したベクトル返す。 cumprod(v) ベクトル v の各要素について、それ以前の要素の総積を格納したベクトル返す。 table(v) ベクトル v のユニークな要素の値それぞれについて、値の等しい要素がいくつあるか集計した名前付き整数ベクトルを返す。 20.1.8 端数処理に関連する関数 floor(v) ベクトル v の各要素について、その値より大きくない最大の整数を格納したベクトルを返す。 ceil(v) ベクトル v の各要素について、その値より小さくない最大の整数を格納したベクトルを返す。 ceiling(v) ceil() と同義。 round(v, digits) ベクトル v の各要素を有効桁数 digits で丸めたベクトルを返す。 trunc(v) ベクトル v の各要素について、小数点以下を切り捨てたベクトルを返す。 20.1.9 数学に関連する関数 sign(v) ベクトル v の各要素について、正なら1を負なら-1を格納したベクトルを返す。 abs(v) ベクトル v の各要素の絶対値を格納したベクトルを返す。 pow(v, n) ベクトル v の各要素を n 乗したベクトルを返す。 sqrt(v) ベクトル v の各要素の平方根をとったベクトルを返す。 exp(v) ネイピア数 e をベクトル v の各要素の値でべき乗したベクトルを返す。 expm1(v) exp(v) - 1 と同義。 log(v) ベクトル v の各要素の自然対数をとったベクトルを返す。 log10(v) ベクトル v の各要素の常用対数をとったベクトルを返す。 log1p(v) log(v+1) と同義。 sin(v) ベクトル v の各要素のサインをとったベクトルを返す。 sinh(v) ベクトル v の各要素のハイパボリックサインをとったベクトルを返す。 cos(v) ベクトル v の各要素のコサインをとったベクトルを返す。 cosh(v) ベクトル v の各要素のハイパボリックコサインをとったベクトルを返す。 tan(v) ベクトル v の各要素のタンジェントをとったベクトルを返す。 tanh(v) ベクトル v の各要素のハイパボリックタンジェントをとったベクトルを返す。 acos(v) ベクトル v の各要素のアークコサインをとったベクトルを返す。 asin(v) ベクトル v の各要素のアークサインをとったベクトルを返す。 atan(v) ベクトル v の各要素のアークタンジェントをとったベクトルを返す。 gamma(v) ベクトル v の各要素をガンマ関数で変換したベクトルを返す。 lgamma(v) log(gamma(v)) と同義。 digamma(v) ベクトル v の各要素を lgamma() の一階微分関数で変換したベクトルを返す。 trigamma(v) ベクトル v の各要素を lgamma() の二階微分関数で変換したベクトルを返す。 tetragamma(v) ベクトル v の各要素を lgamma() の三階微分関数で変換したベクトルを返す。 pentagamma(v) ベクトル v の各要素を lgamma() の四階微分関数で変換したベクトルを返す。 psigamma(v, deriv) ベクトル v の各要素を digamma(v) の deriv 階微分関数で変換したベクトルを返す。 factrial(v) ベクトル v の各要素の階乗をとったベクトルを返す。 lfactorial(v) log(factrial(v)) と同義。 choose(vn, vk) 実数ベクトル vn、整数ベクトル vk の対応する各要素を用いて二項係数を計算したベクトルを返す。 lchoose(vn, vk) log(choose(vn, vk)) と同義。 beta(va, vb) ベクトル va, vb の対応する各要素を用いてベータ関数の値を計算したベクトルを用います。 lbeta(va, vb) log(beta(va, vb)) と同義。 20.1.10 論理値に関連する関数 all(v) 論理ベクトル v を受け取り、全ての要素が TRUE の時、TRUE を意味する SingleLogicalResult 型を返す。 any(v) 論理ベクトル v を受け取り、いずれかのの要素が TRUE の時、TRUE を意味する SingleLogicalResult 型を返す。 is_true(x) all(), any() の返値 x を受け取り TRUE の場合には true を bool 型で返す。 is_false(x) all(), any() の返値 x を受け取り FALSE の場合には true を bool 型で返す。 is_na(x) all(), any() の返値 x を受け取り NA の場合には true を bool 型で返す。 ifelse(v, x1, x2) 論理ベクトル v を受け取り、v の要素が TRUE の時には x1 の対応する要素を, FALSE の時には x2 の対応する要素を格納したベクトルを返す。x1, x2 はベクトルでもスカラーでも良いが、ベクトルの長さは v と一致している必要がある。 20.1.11 NA、Inf、NaNに関連する関数 na_omit(v) ベクトル v から NAを削除したベクトルを返す。 is_finite(v) ベクトル v の各要素が Inf または -Inf または NA ではない場合に TRUE を格納した論理ベクトルを返す。 is_infinite(v) ベクトル v の各要素が Inf または -Inf である場合に TRUE を格納した論理ベクトルを返す。 is_na(v) ベクトル v の各要素が NA または NaN である場合に TRUE を格納した論理ベクトルを返す。 is_nan(v) ベクトル v の各要素が NaN である場合に TRUE を格納した論理ベクトルを返す。 20.1.12 apply関数 lapply(x, fun) Vector x の各要素に対してC++の関数 fun を適用した結果を List で返す。 sapply(x, fun) Vector x の各要素に対してC++の関数 fun を適用した結果を Vector で返す。 mapply(x1, x2, fun2) Vector x の各要素に対して2個の引数を受け取るC++の関数 fun2 を適用した結果を Vector で返す。 mapply(x1, x2, x3, fun3) Vector x の各要素に対して3個の引数を受け取るC++の関数 fun3 を適用した結果を Vector で返す。 20.1.13 cbind関数 cbind(v1,v2,…) 引数として渡した Vector または Matrix を列方向に結合した Matrix または DataFrame を返します。渡せる引数の数は50個まで。 "],
["210_dpqr_functions.html", "Chapter 21 確率分布 21.1 確率分布関数の基本構造 21.2 確率分布関数の一覧 21.3 連続分布 21.4 離散分布", " Chapter 21 確率分布 Rcpp は R にある主要な全ての確率分布関数を提供します。R と同じく各確率分布のそれぞれについて d p q r の文字から始まる４つの関数が定義されています。 確率分布 XXX に関する４つの関数 dXXX: 確率密度関数 pXXX: 累積分布関数 qXXX: 分位関数 rXXX: 乱数生成関数 21.1 確率分布関数の基本構造 Rcpp では、同じ名前の確率分布関数が R:: と Rcpp:: の２つの名前空間で定義されています。これらの違いは、Rcpp:: 名前空間で定義されている確率分布関数はベクトルを返すのに対して、R:: 名前空間の関数はスカラーを返すということです。通常は Rcpp:: 名前空間の関数を使えば良いですが、スカラー値が欲しい場合は R:: 名前空間の関数のほうが速度が速いためそちらを用いたほうが良いでしょう。 下に Rcpp:: 名前空間で定義されている確率分布関数の基本構造を示します。基本的には Rcpp:: 名前空間で定義されている確率分布関数は R にある確率分布関数と同じ機能を持っています。実際にはソースコード中に Rcpp:: 名前空間の確率分布関数の定義はそのまま書かれてはいない（マクロを使って記述されているため）のですが、ユーザーにとってはこのような形式の関数が定義されていると考えて差し支えありません。 NumericVector Rcpp::dXXX( NumericVector x, double par, bool log = false ) NumericVector Rcpp::pXXX( NumericVector q, double par, bool lower = true, bool log = false ) NumericVector Rcpp::qXXX( NumericVector p, double par, bool lower = true, bool log = false ) NumericVector Rcpp::rXXX( int n, double par ) 次に R:: 名前空間で定義されている確率分布関数の基本構造を示します。これは double を受け取り double を返すという点以外は Rcpp:: 名前空間で定義されている確率分布関数と基本的には同じ機能を持っています。しかし、引数のデフォルト値は与えられていないのでユーザーが明示的に与える必要があります。 double R::dXXX( double x, double par, int log ) double R::pXXX( double q, double par, int lower, int log ) double R::qXXX( double p, double par, int lower, int log ) double R::rXXX( double par ) 下に確率分布関数の引数の説明を示します。 引数 説明 x, q 確率変数の値（のベクトル） p 分位数を求めたい確率値（のベクトル） n 発生させたい乱数の個数 par 分布パラメータの値（実際には確率分布によって分布パラメータの数は異なる） lower true : 確率変数の値が x 以下の領域の確率を算出する、false : x より大の領域の確率を算出する log true : 確率を対数変換した値を算出する 21.2 確率分布関数の一覧 以下では Rcpp が提供する確率分布関数の一覧を示します。ここでは確率分布の分布パラメータの名前は R の確率分布関数と一致させているので、詳しくは R のヘルプを参照してください。 21.2.1 連続分布 一様分布 正規分布 対数正規分布 ガンマ分布 ベータ分布 非心ベータ分布 カイ２乗分布 非心カイ２乗分布 t分布 非心t分布 F分布 非心F分布 コーシー分布 指数分布 ロジスティック分布 ワイブル分布 21.2.2 離散分布 二項分布 負の二項分布（成功確率を指定するバージョン） 負の二項分布（平均値を指定するバージョン） ポワソン分布 幾何分布 超幾何分布 ウィルコクソン順位和検定統計量の分布 ウィルコクソン符号順位検定統計量の分布 21.3 連続分布 21.3.1 一様分布 区間 min から max の一様分布の情報を与えます。 Rcpp::dunif( x, min = 0.0, max = 1.0, log = false ) Rcpp::punif( x, min = 0.0, max = 1.0, lower = true, log = false ) Rcpp::qunif( q, min = 0.0, max = 1.0, lower = true, log = false ) Rcpp::runif( n, min = 0.0, max = 1.0 ) R::dunif( x, min, max, log ) R::punif( x, min, max, lower, log ) R::qunif( q, min, max, lower, log ) R::runif( min, max ) 21.3.2 正規分布 平均値 mean 標準偏差 sd の正規分布の情報を与えます。 Rcpp::dnorm( x, mean = 0.0, sd = 1.0, log = false ) Rcpp::pnorm( x, mean = 0.0, sd = 1.0, lower = true, log = false ) Rcpp::qnorm( q, mean = 0.0, sd = 1.0, lower = true, log = false ) Rcpp::rnorm( n, mean = 0.0, sd = 1.0 ) R::dnorm( x, mean, sd, log ) R::pnorm( x, mean, sd, lower, log ) R::qnorm( q, mean, sd, lower, log ) R::rnorm( mean, sd ) 21.3.3 対数正規分布 位置パラメータmeanlog 尺度パラメータ meansd の対数正規分布の情報を与えます。 Rcpp::dlnorm( x, meanlog = 0.0, sdlog = 1.0, log = false ) Rcpp::plnorm( x, meanlog = 0.0, sdlog = 1.0, lower = true, log = false ) Rcpp::qlnorm( q, meanlog = 0.0, sdlog = 1.0, lower = true, log = false ) Rcpp::rlnorm( n, meanlog = 0.0, sdlog = 1.0 ) R::dlnorm( x, meanlog, sdlog, log ) R::plnorm( x, meanlog, sdlog, lower, log ) R::qlnorm( q, meanlog, sdlog, lower, log ) R::rlnorm( meanlog, sdlog ) 21.3.4 ガンマ分布 形状パラメータ shape、尺度パラメータ scale のガンマ分布の情報を与えます。 Rcpp::dgamma( x, shape, scale = 1.0, log = false ) Rcpp::pgamma( x, shape, scale = 1.0, lower = true, log = false ) Rcpp::qgamma( q, shape, scale = 1.0, lower = true, log = false ) Rcpp::rgamma( n, shape, scale = 1.0 ) R::dgamma( x, shape, scale, log ) R::pgamma( x, shape, scale, lower, log ) R::qgamma( q, shape, scale, lower, log ) R::rgamma( shape, scale ) 21.3.5 ベータ分布 形状パラメータ shape1, shape2 を持つベータ分布の情報を与えます。これは R のベータ分布関数において非心パラメータ ncp の値に 0 を設定した場合に相当します。 Rcpp::dbeta( x, shape1, shape2, log = false ) Rcpp::pbeta( x, shape1, shape2, lower = true, log = false ) Rcpp::qbeta( q, shape1, shape2, lower = true, log = false ) Rcpp::rbeta( n, shape1, shape2) R::dbeta( x, shape1, shape2, log ) R::pbeta( x, shape1, shape2, lower, log ) R::qbeta( q, shape1, shape2, lower, log ) R::rbeta( shape1, shape2 ) 21.3.6 非心ベータ分布 形状パラメータ shape1、shape2、非心パラメータ ncp を持つベータ分布の情報を与えます。ncp = 0 ではベータ分布に一致します。 Rcpp::dnbeta( x, shape1, shape2, ncp, log = false ); Rcpp::pnbeta( x, shape1, shape2, ncp, lower = true, log = false ); Rcpp::qnbeta( q, shape1, shape2, ncp, lower = true, log = false ); // Rcpp::rnbeta関数は存在しません R::dnbeta( x, shape1, shape2, ncp, log ) R::pnbeta( x, shape1, shape2, ncp, lower, log ) R::qnbeta( q, shape1, shape2, ncp, lower, log ) R::rnbeta( shape1, shape2, ncp ) 21.3.7 カイ２乗分布 自由度 df のカイ2乗分布の情報を与えます。これは R のカイ２乗分布関数において非心パラメータ ncp の値に 0 を設定した場合に相当します。 Rcpp::dchisq( x, df, log = false ) Rcpp::pchisq( x, df, lower = true, log = false ) Rcpp::qchisq( q, df, lower = true, log = false ) Rcpp::rchisq( n, df) R::dchisq( x, df, log ) R::pchisq( x, df, lower, log ) R::qchisq( q, df, lower, log ) R::rchisq( df ) 21.3.8 非心カイ２乗分布 自由度 df 、非心パラメータ ncp を持つベータ分布の情報を与えます。ncp = 0 ではカイ２乗分布に一致します。 Rcpp::dnchisq( x, df, ncp, log = false ) Rcpp::pnchisq( x, df, ncp, lower = true, log = false ) Rcpp::qnchisq( q, df, ncp, lower = true, log = false ) Rcpp::rnchisq( n, df, ncp = 0.0 ) R::dnchisq( x, df, ncp, log ) R::pnchisq( x, df, ncp, lower, log ) R::qnchisq( q, df, ncp, lower, log ) R::rnchisq( df, ncp ) 21.3.9 t分布 自由度 df の t 分布の情報を与えます。これは R の t 分布関数において非心パラメータ ncp の値に 0 を設定した場合に相当します。 Rcpp::dt( x, df, log = false ) Rcpp::pt( x, df, lower = true, log = false ) Rcpp::qt( q, df, lower = true, log = false ) Rcpp::rt( n, df ) R::dt( x, df, log ) R::pt( x, df, lower, log ) R::qt( q, df, lower, log ) R::rt( df ) 21.3.10 非心t分布 自由度 df、非心パラメータ ncp の t 分布の情報を与えます。ncp = 0 では t 分布に一致します。 Rcpp::dnt( x, df, ncp, log = false ) Rcpp::pnt( x, df, ncp, lower = true, log = false ) Rcpp::qnt( q, df, ncp, lower = true, log = false ) // Rcpp::rnt関数は存在しません R::dnt( x, df, ncp, log ) R::pnt( x, df, ncp, lower, log ) R::qnt( q, df, ncp, lower, log ) // R::rnt関数は存在しません 21.3.11 F分布 自由度 df1, df2 のF分布の情報を与えます。これは R のF分布関数において非心パラメータ ncp の値に 0 を設定した場合に相当します。 Rcpp::df( x, df1, df2, log = false ) Rcpp::pf( x, df1, df2, lower = true, log = false ) Rcpp::qf( q, df1, df2, lower = true, log = false ) Rcpp::rf( n, df1, df1 ) R::df( x, df1, df2, log ) R::pf( x, df1, df2, lower, log ) R::qf( q, df1, df2, lower, log ) R::rf( df1, df2 ) 21.3.12 非心F分布 自由度 df1, df2 非心パラメータ ncp の F 分布の情報を与えます。ncp = 0 では F 分布に一致します。 Rcpp::dnf( x, df1, df2, ncp, log = false ) Rcpp::pnf( x, df1, df2, ncp, lower = true, log = false ) Rcpp::qnf( q, df1, df2, ncp, lower = true, log = false ) // Rcpp::rnf関数は存在しません R::dnf( x, df1, df2, ncp, log ) R::pnf( x, df1, df2, ncp, lower, log ) R::qnf( q, df1, df2, ncp, lower, log ) // R::rnf関数は存在しません 21.3.13 コーシー分布 位置パラメータ location、尺度パラメータ scale のコーシー分布の情報を与えます。 Rcpp::dcauchy( x, location = 0.0, scale = 1.0, log = false ) Rcpp::pcauchy( x, location = 0.0, scale = 1.0, lower = true, log = false ) Rcpp::qcauchy( q, location = 0.0, scale = 1.0, lower = true, log = false ) Rcpp::rcauchy( n, location = 0.0, scale = 1.0) R::dcauchy( x, location, scale, log ) R::pcauchy( x, location, scale, lower, log ) R::qcauchy( q, location, scale, lower, log ) R::rcauchy( location, scale ) 21.3.14 指数分布 割合 rate (平均が1/rate) の指数分布の情報を与えます。 Rcpp::dexp( x, rate = 1.0, log = false ) Rcpp::pexp( x, rate = 1.0, lower = true, log = false ) Rcpp::qexp( q, rate = 1.0, lower = true, log = false ) Rcpp::rexp( n, rate = 1.0) R::dexp( x, rate, log ) R::pexp( x, rate, lower, log ) R::qexp( q, rate, lower, log ) R::rexp( rate ) 21.3.15 ロジスティック分布 位置パラータ location 尺度パラメータ scale のロジスティック分布の情報を与えます。 Rcpp::dlogis( x, location = 0.0, scale = 1.0, log = false ) Rcpp::plogis( x, location = 0.0, scale = 1.0, lower = true, log = false ) Rcpp::qlogis( q, location = 0.0, scale = 1.0, lower = true, log = false ) Rcpp::rlogis( n, location = 0.0, scale = 1.0 ) R::dlogis( x, location, scale, log ) R::plogis( x, location, scale, lower, log ) R::qlogis( q, location, scale, lower, log ) R::rlogis( location, scale ) 21.3.16 ワイブル分布 形状パラメータ shape、尺度パラメータ scale のワイブル分布の情報を与えます。 Rcpp::dweibull( x, shape, scale = 1.0, log = false ) Rcpp::pweibull( x, shape, scale = 1.0, lower = true, log = false ) Rcpp::qweibull( q, shape, scale = 1.0, lower = true, log = false ) Rcpp::rweibull( n, shape, scale = 1.0 ) R::dweibull( x, shape, scale, log ) R::pweibull( x, shape, scale, lower, log ) R::qweibull( q, shape, scale, lower, log ) R::rweibull( shape, scale ) 21.4 離散分布 21.4.1 二項分布 試行回数 size 成功確率 prob の二項分布の情報を与えます。 Rcpp::dbinom( x, size, prob, log = false ) Rcpp::pbinom( x, size, prob, lower = true, log = false ) Rcpp::qbinom( q, size, prob, lower = true, log = false ) Rcpp::rbinom( n, size, prob ) R::dbinom( x, size, prob, log ) R::pbinom( x, size, prob, lower, log ) R::qbinom( q, size, prob, lower, log ) R::rbinom( size, prob ) 21.4.2 負の二項分布（成功確率を指定するバージョン） 成功回数 size、１試行あたりの成功確率 prob の負の二項分布の情報を与えます。 Rcpp::dnbinom( x, size, prob, log = false ) Rcpp::pnbinom( x, size, prob, lower = true, log = false ) Rcpp::qnbinom( q, size, prob, lower = true, log = false ) Rcpp::rnbinom( n, size, prob ) R::dnbinom( x, size, prob, log ) R::pnbinom( x, size, prob, lower, log ) R::qnbinom( q, size, prob, lower, log ) R::rnbinom( size, prob ) 21.4.3 負の二項分布（平均値を指定するバージョン） 成功回数 size、分布の平均が mu (=size/prob) の負の二項分布の情報を与えます。 Rcpp::dnbinom_mu( x, size, mu, log = false ) Rcpp::pnbinom_mu( x, size, mu, lower = true, log = false ) Rcpp::qnbinom_mu( q, size, mu, lower = true, log = false ) Rcpp::rnbinom_mu( n, size, mu ) R::dnbinom_mu( x, size, mu, log ) R::pnbinom_mu( x, size, mu, lower, log ) R::qnbinom_mu( q, size, mu, lower, log ) R::rnbinom_mu( size, mu ) 21.4.4 ポワソン分布 平均値と分散が lambda であるポワソン分布の情報を与えます。 Rcpp::dpois( x, lambda, log = false ) Rcpp::ppois( x, lambda, lower = true, log = false ) Rcpp::qpois( q, lambda, lower = true, log = false ) Rcpp::rpois( n, lambda ) R::dpois( x, lambda, log ) R::ppois( x, lambda, lower, log ) R::qpois( q, lambda, lower, log ) R::rpois( lambda ) 21.4.5 幾何分布 成功確率 prob の幾何分布の情報を与えます。 Rcpp::dgeom( x, prob, log = false ) Rcpp::pgeom( x, prob, lower = true, log = false ) Rcpp::qgeom( q, prob, lower = true, log = false ) Rcpp::rgeom( n, prob ) R::dgeom( x, prob, log ) R::pgeom( x, prob, lower, log ) R::qgeom( q, prob, lower, log ) R::rgeom( prob ) 21.4.6 超幾何分布 母集団に含まれる成功数 m、母集団に含まれる失敗数 n、母集団からサンプリングする標本の数 k の超幾何分布の情報を与えます。 Rcpp::dhyper( x, m, n, k, log = false ) Rcpp::phyper( x, m, n, k, lower = true, log = false ) Rcpp::qhyper( q, m, n, k, lower = true, log = false ) Rcpp::rhyper(nn, m, n, k ) R::dhyper( x, m, n, k, log ) R::phyper( x, m, n, k, lower, log ) R::qhyper( q, m, n, k, lower, log ) R::rhyper( m, n, k ) 21.4.7 ウィルコクソン順位和検定統計量の分布 標本数がそれぞれ m、n である２つの標本に対してウィルコクソン順位和検定（マン・ホイットニーのU検定）を行ったときの検定統計量の分布の情報を与えます。 // Rcpp::dwilcox関数は存在しません // Rcpp::pwilcox関数は存在しません // Rcpp::qwilcox関数は存在しません Rcpp::rwilcox( nn, m, n ); R::dwilcox( x, m, n, log ) R::pwilcox( x, m, n, lower, log ) R::qwilcox( q, m, n, lower, log ) R::rwilcox( m, n ) 21.4.8 ウィルコクソン符号順位検定統計量の分布 n 個の標本への各2回の観察に対してウィルコクソン符号順位検定を行ったときの検定統計量の分布の情報を与えます。 // Rcpp::dsignrank関数は存在しません // Rcpp::psignrank関数は存在しません // Rcpp::qsignrank関数は存在しません Rcpp::rsignrank( nn, n ) R::dsignrank( x, n, log ) R::psignrank( x, n, lower, log ) R::qsignrank( q, n, lower, log ) R::rsignrank( n ) "],
["220_R_function.html", "Chapter 22 Rの関数を利用する 22.1 Function を用いた方法 22.2 Environment を用いた方法", " Chapter 22 Rの関数を利用する Rcpp 内で R の関数を利用するには、Function、Environment を用います。 22.1 Function を用いた方法 Function クラスを使うと、Rcpp 内から R の関数を呼び出すことができます。R の関数に与えた値がどの引数に渡されるかは、位置と名前に基づいて判断されます。 名前を指定して引数に値を渡すには Named() 関数または _[] を使用します。Name() は、Named(&quot;引数名&quot;, 値) か Named(&quot;引数名&quot;) = 値 の２つの方法で用いることができます。 下のコード例では、Rcpp で定義した関数の中で R の関数 rnorm(n, mean, sd) を呼び出す例を示します。なお、この方法でパッケージの関数を呼び出す場合は、あらかじめ R で library 関数などを用いてパッケージの環境をサーチパスに追加しておく必要があります。 // [[Rcpp::export]] NumericVector my_fun(){ // rnorm 関数を呼び出す Function f(&quot;rnorm&quot;); // 次の例は rnorm(n=5, mean=10, sd=2)と解釈されます // 1番目の引数は位置にもとづき n に渡され // 2, 3番目の引数は名前にもとづきsd,meanに渡されます return f(5, Named(&quot;sd&quot;)=2, _[&quot;mean&quot;]=10); } 実行例 &gt; my_fun() [1] 8.014863 10.459980 7.741581 9.000762 11.465920 上の例では、Rcpp で呼び出される R の関数の返値の型は NumericVector である前提になっています。しかし、下の例のように Rcpp 関数内で呼び出される R の関数の返値の型が決まっていない場合もよくあります。そのような場合には、どんな型でも代入できる RObject か List に関数の返値を代入するようにすると良いでしょう。 下のコード例では、R の lapply() を単純化した関数を Rcpp で定義する例を示します。 // [[Rcpp::export]] List rcpp_lapply(List input, Function f) { // リスト input の各要素に関数 f を適用した結果をリストとして返します // リストの要素数 n R_xlen_t n = input.length(); // 出力用に要素数が n のリストを作成します List out(n); // input の各要素に f() を適用して out に格納します // f() の返値の型は不明ですがリストには代入可能です for(R_xlen_t i = 0; i &lt; n; ++i) { out[i] = f(input[i]); } return out; } 22.2 Environment を用いた方法 Environment クラスを利用するとパッケージ等の環境からオブジェクト（変数や関数）を取り出すことができます。 下のコード例では、パッケージ Matrix にある関数 Matrix() を呼び出す例を示します。なお、この方法でパッケージの関数を呼び出す場合には、library 関数を用いてパッケージの環境をサーチパスに追加する必要はありません。 // [[Rcpp::export]] S4 rcpp_package_function(NumericMatrix m){ // Matrix パッケージの名前空間を取得します Environment pkg = Environment::namespace_env(&quot;Matrix&quot;); // Matrix パッケージの Matrix 関数を取得します Function f = pkg[&quot;Matrix&quot;]; // Matrix( m, sparse = TRIE ) を実行します return f( m, Named(&quot;sparse&quot;, true)); } 実行結果 &gt; m &lt;- matrix(c(1,0,0,2), nrow = 2, ncol = 2) &gt; rcpp_package_function(m) 2 x 2 sparse Matrix of class &quot;dsCMatrix&quot; [1,] 1 . [2,] . 2 "],
["230_na_nan_inf.html", "Chapter 23 NA NaN Inf NULL 23.1 NA NaN Inf の値 23.2 NA NaN Inf の判定 23.3 NULL 23.4 Rcpp で NA を扱う際の注意点", " Chapter 23 NA NaN Inf NULL 23.1 NA NaN Inf の値 Rcpp で Inf -Inf NaN の値を表現するには R_PosInf R_NegInf R_NaN の記号を用います。 Rでの値 Rcppでの表記 Inf|R_PosInf| |-Inf|R_NegInf| |NaN|R_NaN` 一方、NA については Vector の型ごとに異なる NA の値が定義されています。 ベクトル型 NA値 NumericVector NA_REAL IntegerVector NA_INTEGER LogicalVector NA_LOGICAL CharacterVector NA_STRING 次のコード例では、これらの記号を使ってベクトルを作成する方法を示します。 NumericVector v1 = NumericVector::create( 1, NA_REAL, R_NaN, R_PosInf, R_NegInf); IntegerVector v2 = IntegerVector::create( 1, NA_INTEGER); CharacterVector v3 = CharacterVector::create( &quot;A&quot;, NA_STRING); LogicalVector v4 = LogicalVector::create( true, NA_LOGICAL); 23.2 NA NaN Inf の判定 23.2.1 ベクトルの要素をまとめて判定する場合 ベクトル v の要素にある、NA NaN Inf -Inf をまとめて判定するには、関数is_na() is_nan() is_infinite() を使います。 下のコード例では、R で NA NaN Inf -Inf を含むベクトルを作成し、それを Rcpp で判定しています。この例から Rcpp の is_na() 関数は R の is.na() 関数と同じく、NA と NaN の両方を true であると判定することがわかります。 NumericVector v = NumericVector::create( 1, NA_REAL, R_NaN, R_PosInf, R_NegInf); LogicalVector l1 = is_na(v); LogicalVector l2 = is_nan(v); LogicalVector l3 = is_infinite(v); Rcout &lt;&lt; l1 &lt;&lt; &quot;\\n&quot;; // 0 1 1 0 0 Rcout &lt;&lt; l2 &lt;&lt; &quot;\\n&quot;; // 0 0 1 0 0 Rcout &lt;&lt; l3 &lt;&lt; &quot;\\n&quot;; // 0 0 0 1 1 これらの関数を使うことでベクトルから NA NaN Inf を取り除くことができます。また NA を取り除くためには na_omit() を使うこともできます。 下のコード例では、関数 is_na() と na_omit() を使ってベクトルから NA を取り除く方法を示します。 // NA を含むベクトルの作成 NumericVector v = NumericVector::create( 1, NA_REAL, 2, NA_REAL, 3); //ベクトルから NA を取り除く NumericVector v1 = v[!is_na(v)]; NumericVector v2 = na_omit(v); 23.2.2 ベクトルの要素１つに対して判定する場合 ベクトルの要素１つに対して NA NaN Inf -Inf の判定を行いたい場合には、ベクトルの静的メンバ関数の Vector::is_na()、traits::is_nan&lt;RTYPE&gt;()、traits:: is_infinite&lt;RTYPE&gt;() を用います。RTYPE には判定したいベクトルの SEXPTYPE を指定します。 // [[Rcpp::export]] void rcpp_is_na2() { // NA NaN Inf -Inf を含んだベクトルの作成 NumericVector v = NumericVector::create(1, NA_REAL, R_NaN, R_PosInf, R_NegInf); // ベクトルの要素ごとに値を判定します int n = v.length(); for (int i = 0; i &lt; n; ++i) { if(NumericVector::is_na(v[i])) Rprintf(&quot;v[%i] is NA.\\n&quot;, i); if(Rcpp::traits::is_nan&lt;REALSXP&gt;(v[i])) Rprintf(&quot;v[%i] is NaN.\\n&quot;, i); if(Rcpp::traits::is_infinite&lt;REALSXP&gt;(v[i])) Rprintf(&quot;v[%i] is Inf or -Inf.\\n&quot;, i); } } 以下に主要なベクトルの SEXPTYPE のリストを示します。 SEXPTYPE ベクトル LGLSXP 論理ベクトル INTSXP 整数ベクトル REALSXP 実数ベクトル CPLXSXP 複素数ベクトル STRSXP 文字列ベクトル 23.3 NULL Rcpp で NULL を扱う場合には R_NilValue を利用します。下のコード例では、NULL がリストの要素に含まれる場合の判定と、NULL を代入して属性の値を消去する例を示します。 // [[Rcpp::export]] List rcpp_list() { // 要素名がついたリストを作成する // ２つの要素のうち１つは NULL になっています List L = List::create(Named(&quot;x&quot;,NumericVector({1,2,3})), Named(&quot;y&quot;,R_NilValue)); // NULL の判定 for(int i=0; i&lt;L.length(); ++i){ if(L[i]==R_NilValue) { Rprintf(&quot;L[%i] is NULL.\\n\\n&quot;, i+1); } } // オブジェクトの属性値（要素名）の値を消去する L.attr(&quot;names&quot;) = R_NilValue; return(L); } 実行結果 &gt; rcpp_list() L[2] is NULL. [[1]] [1] 1 2 3 [[2]] NULL 23.4 Rcpp で NA を扱う際の注意点 内部的には NA_INTEGER と NA_LOGICAL には int の最小値 (-2147483648) がセットされています。Rcpp で定義された関数や演算子は int の最小値を NA として適切に扱ってくれます（つまり、NA の要素に対する演算の結果を NA にします）。しかし、標準 C++ の関数や演算子は int の最小値を単なる数値としてそのまま扱います。そのため、例えば IntegerVector の NA に 1 を足すと、結果は int の最小値ではなくなるため、もはや NA ではなくなってしまいます。 加えて bool 型に NA を代入した場合には常に true になります。これは bool は 0 以外の数値をすべて true と評価するためです。 一方、double には nan と inf が定義されているため、標準 C++ でも nan inf に対する演算の結果は、R と同様の結果なるため問題はありません。 下の表では、R の NA Inf -Inf NaN の値を Vector やスカラー型に対して代入したときに、どのような値として評価されるのかまとめています。 NA NaN Inf -Inf NumericVector NA_REAL R_NaN R_PosInf R_NegInf IntegerVector NA_INTEGER NA_INTEGER NA_INTEGER NA_INTEGER LogicalVector NA_LOGICAL NA_LOGICAL NA_LOGICAL NA_LOGICAL CharacterVector NA_STRING “NaN” “Inf” “-Inf” String NA_STRING “NaN” “Inf” “-Inf” double nan nan inf -inf int -2147483648 -2147483648 -2147483648 -2147483648 bool true true true true 下のコード例は、NA_INTEGER に対して Rcpp の演算子と標準 C++ の演算子を用いて演算を行った時の結果の違いを示しています。この実行結果から Rcpp の演算子は NA に対する演算の結果を NA にしますが、標準 C++ の演算子は整数ベクトルの NA を数値として扱っていることがわかります。 // [[Rcpp::export]] List rcpp_na_sum(){ // NA を含む整数ベクトルを作成します IntegerVector v1 = IntegerVector::create(1,NA_INTEGER,3); // Rcpp で定義されたベクトルとスカラーの + 演算子を適用します IntegerVector res1 = v1 + 1; // 標準 C++ で定義された int と int の + 演算子を適用します IntegerVector res2(3); for(int i=0; i&lt;v1.length(); ++i){ res2[i] = v1[i] + 1; } // 結果をリストで出力します return List::create(Named(&quot;Rcpp plus&quot;, res1), Named(&quot;C++ plus&quot;, res2)); } 実行結果 &gt; rcpp_na_sum() $`Rcpp plus` [1] 2 NA 4 $`C++ plus` [1] 2 -2147483647 4 "],
["240_attributes.html", "Chapter 24 属性値 24.1 主要な属性値", " Chapter 24 属性値 Rcppのオブジェクトの属性値へアクセスするには、次のメンバ関数を用います。 24.0.0.1 attr( name ) 文字列 name で指定した属性値へアクセスして値の取得や設定を行います。 List L; L.attr(&quot;class&quot;) = &quot;my_class&quot;; 24.0.0.2 attributeNames() オブジェクトが持っている属性の一覧を返します。返値の型は C++ の vector&lt;string&gt; なので、CharacterVector に変換する場合には wrap() 関数を用います。 CharacterVector ch = wrap(x.attributeNames()); 24.0.0.3 hasAttribute( name ) このオブジェクトが 文字列 name で指定した名前の属性を持っている場合は true を返します。 bool b = x.hasAttribute(&quot;name&quot;); // リストを作成します NumericVector v1 = {1,2,3,4,5}; CharacterVector v2 = {&quot;A&quot;,&quot;B&quot;,&quot;C&quot;}; List L = List::create(v1, v2); // 要素に名前を設定します L.attr(&quot;names&quot;) = CharacterVector::create(&quot;x&quot;, &quot;y&quot;); // 新しい属性を作成して、その値をセットします。 L.attr(&quot;new_attribute&quot;) = &quot;new_value&quot;; // このオブジェクトのクラス名を &quot;new_class&quot; に変更します L.attr(&quot;class&quot;) = &quot;new_class&quot;; // このオブジェクトが持つ属性の一覧を出力します CharacterVector ch = wrap(L.attributeNames()); Rcout &lt;&lt; ch &lt;&lt; &quot;\\n&quot;; // &quot;names&quot; &quot;new_attribute&quot; &quot;class&quot; // このオブジェクトが属性 &quot;new_attribute&quot; を持っているか確かめます bool b = L.hasAttribute(&quot;new_attribute&quot;); Rcout &lt;&lt; b &lt;&lt; &quot;\\n&quot;; // 1 24.1 主要な属性値 要素名など使用頻度の高い属性については専用のアクセス関数が用意されている場合があります。 //要素名、これらは同義である x.attr(&quot;names&quot;); x.names(); 下に主要な属性値へのアクセス方法を示す Vector v v.attr(&quot;names&quot;);//要素名 v.names(); //要素名 Matrix m; m.ncol(); //列数 m.nrow(); //行数 m.attr(“dim”) = NumericVector::create(行数, 列数); m.attr(“dimnames”) = List::create(行名ベクトル, 列名ベクトル); DataFrame df; df.attr(“names”); //列名 df.attr(“row.names”); //行名 List L; L.names(); //要素名 "],
["250_factor.html", "Chapter 25 factor", " Chapter 25 factor 因子ベクトル（factor）の実体は属性 levels が定義された整数ベクトルです。因子ベクトルの各要素の値は、属性 levels の最初の要素に対応する値が 1、次の要素に対応する値が 2、というようになっています。 下の例では、IntergerVector に属性を指定することで factor に変換する例を示しています。 // factor の作成 // [[Rcpp::export]] RObject rcpp_factor(){ IntegerVector v = {1,2,3,1,2,3}; CharacterVector ch = {&quot;A&quot;,&quot;B&quot;,&quot;C&quot;}; v.attr(&quot;class&quot;) = &quot;factor&quot;; v.attr(&quot;levels&quot;) = ch; return v; } 下の実行結果を見ると R に返された整数ベクトル v は factor 型として扱われていることがわかります。 &gt; rcpp_factor() [1] A B C A B C Levels: A B C "],
["260_error.html", "Chapter 26 エラー処理 26.1 stop()とwarning() 26.2 C++ 例外を投げる", " Chapter 26 エラー処理 プログラムの正常な進行が妨げられる自体が起きた場合には、エラーメッセージ（C++ 例外）を発し、プログラムをストップさせることができます。 26.1 stop()とwarning() プログラムの正常な進行が妨げられる事態が起きた場合には、stop() 関数を用いてエラーメッセージを表示し実行を停止させることができます。プログラムの進行を停止せずに、ユーザーに警告を発したい場合は warning() 関数を用います。関数 stop() と warning() のどちらとも Rprintf() 関数と同じように書式を指定してメッセージを表示することができます。 stop(&quot;Error: Unexpected condition occurred&quot;); stop(&quot;Error: Column %i is not numeric.&quot;, i+1); warning(&quot;Warning: Unexpected condition occurred&quot;); warning(&quot;Warning: Column %i is not numeric.&quot;, i+1); 下のコード例では、関数に与えた数値がマイナスであった場合にエラーを出力して実行を停止します。 // [[Rcpp::export]] double rcpp_log(double x) { if (x &lt;= 0.0) { stop(&quot;&#39;x&#39; must be a positive value.&quot;); } return log(x); } 実行結果 &gt; rcpp_log(-1) エラー: &#39;x&#39; must be a positive value. 26.2 C++ 例外を投げる throw exception() を使うことで、C++ の例外を throw する事もできます。 throw exception(&quot;Unexpected condition occurred&quot;); "],
["270_miscellaneous.html", "Chapter 27 キャンセル処理", " Chapter 27 キャンセル処理 27.0.1 ユーザーからのキャンセルを受け付ける。 checkUserInterrupt() は処理の実行途中でユーザーが処理をキャンセルするため「ctrl + c」ボタンが押されたかどうかを確認し、押されていた場合には処理を中止します。長時間を要する処理を実行する場合には、おおよそ数秒に１回程度の頻度で checkUserInterrupt() が実行されるようにすると良いでしょう。 for (int i=0; i&lt;100000; ++i) { // 1000 繰り返しごとに中断をチェックします if (i % 1000 == 0) Rcpp::checkUserInterrupt(); do_something(); } "],
["271_Rmath.html", "Chapter 28 R Math Library", " Chapter 28 R Math Library R Math Library はRが提供する数学や統計などの関数を提供するライブラリであり、Rmath.h ヘッダーに記述されています。Rmath 自体は独立したライブラリーとして機能するので、他のプログラムからでも利用できます。 Rcpp からも Rmath.h で定義された関数を呼び出す事ができます。それらは R:: 名前空間の中で定義されています。これらの関数はC言語で書かれており、ベクトル化されていません。 R:: double norm_rand(void) double unif_rand(void) double exp_rand(void) void pnorm_both(double x, double *cum, double *ccum, int lt, int lg) void rmultinom(int n, double* prob, int k, int* rn) double dsignrank(double x, double n, int lg) double psignrank(double x, double n, int lt, int lg) double qsignrank(double x, double n, int lt, int lg) double rsignrank(double n) double dwilcox(double x, double m, double n, int lg) double pwilcox(double q, double m, double n, int lt, int lg) double qwilcox(double x, double m, double n, int lt, int lg) double rwilcox(double m, double n) double ptukey(double q, double rr, double cc, double df, int lt, int lg) double qtukey(double p, double rr, double cc, double df, int lt, int lg) double log1pmx(double x) double log1pexp(double x) double lgamma1p(double a) double logspace_add(double lx, double ly) double logspace_sub(double lx, double ly) double gammafn(double x) double lgammafn(double x) double lgammafn_sign(double x, int *sgn) void dpsifn(double x, int n, int kode, int m, double *ans, int *nz, int *ierr) double psigamma(double x, double deriv) double digamma(double x) double trigamma(double x) double tetragamma(double x) double pentagamma(double x) double beta(double a, double b) double lbeta(double a, double b) double choose(double n, double k) double lchoose(double n, double k) double bessel_i(double x, double al, double ex) double bessel_j(double x, double al) double bessel_k(double x, double al, double ex) double bessel_y(double x, double al) double bessel_i_ex(double x, double al, double ex, double *bi) double bessel_j_ex(double x, double al, double *bj) double bessel_k_ex(double x, double al, double ex, double *bk) double bessel_y_ex(double x, double al, double *by) double hypot(double a, double b) double pythag(double a, double b) double expm1(double x); /* exp(x)-1 {care for small x} */ double log1p(double x); /* log(1+x) {care for small x} */ int imax2(int x, int y) int imin2(int x, int y) double fmax2(double x, double y) double fmin2(double x, double y) double sign(double x) double fprec(double x, double dg) double fround(double x, double dg) double fsign(double x, double y) double ftrunc(double x) double dnorm(double x, double mu, double sigma, int lg) double pnorm(double x, double mu, double sigma, int lt, int lg) double qnorm(double p, double mu, double sigma, int lt, int lg) double rnorm(double mu, double sigma) double dunif(double x, double a, double b, int lg) double punif(double x, double a, double b, int lt, int lg) double qunif(double p, double a, double b, int lt, int lg) double runif(double a, double b) double dgamma(double x, double shp, double scl, int lg) double pgamma(double x, double alp, double scl, int lt, int lg) double qgamma(double p, double alp, double scl, int lt, int lg) double rgamma(double a, double scl) double dbeta(double x, double a, double b, int lg) double pbeta(double x, double p, double q, int lt, int lg) double qbeta(double a, double p, double q, int lt, int lg) double rbeta(double a, double b) double dlnorm(double x, double ml, double sl, int lg) double plnorm(double x, double ml, double sl, int lt, int lg) double qlnorm(double p, double ml, double sl, int lt, int lg) double rlnorm(double ml, double sl) double dchisq(double x, double df, int lg) double pchisq(double x, double df, int lt, int lg) double qchisq(double p, double df, int lt, int lg) double rchisq(double df) double dnchisq(double x, double df, double ncp, int lg) double pnchisq(double x, double df, double ncp, int lt, int lg) double qnchisq(double p, double df, double ncp, int lt, int lg) double rnchisq(double df, double lb) double df(double x, double df1, double df2, int lg) double pf(double x, double df1, double df2, int lt, int lg) double qf(double p, double df1, double df2, int lt, int lg) double rf(double df1, double df2) double dt(double x, double n, int lg) double pt(double x, double n, int lt, int lg) double qt(double p, double n, int lt, int lg) double rt(double n) double dbinom(double x, double n, double p, int lg) double pbinom(double x, double n, double p, int lt, int lg) double qbinom(double p, double n, double m, int lt, int lg) double rbinom(double n, double p) double dcauchy(double x, double lc, double sl, int lg) double pcauchy(double x, double lc, double sl, int lt, int lg) double qcauchy(double p, double lc, double sl, int lt, int lg) double rcauchy(double lc, double sl) double dexp(double x, double sl, int lg) double pexp(double x, double sl, int lt, int lg) double qexp(double p, double sl, int lt, int lg) double rexp(double sl) double dgeom(double x, double p, int lg) double pgeom(double x, double p, int lt, int lg) double qgeom(double p, double pb, int lt, int lg) double rgeom(double p) double dhyper(double x, double r, double b, double n, int lg) double phyper(double x, double r, double b, double n, int lt, int lg) double qhyper(double p, double r, double b, double n, int lt, int lg) double rhyper(double r, double b, double n) double dnbinom(double x, double sz, double pb, int lg) double pnbinom(double x, double sz, double pb, int lt, int lg) double qnbinom(double p, double sz, double pb, int lt, int lg) double rnbinom(double sz, double pb) double dnbinom_mu(double x, double sz, double mu, int lg) double pnbinom_mu(double x, double sz, double mu, int lt, int lg) double qnbinom_mu(double x, double sz, double mu, int lt, int lg) double rnbinom_mu(double sz, double mu) double dpois(double x, double lb, int lg) double ppois(double x, double lb, int lt, int lg) double qpois(double p, double lb, int lt, int lg) double rpois(double mu) double dlogis(double x, double lc, double sl, int lg) double plogis(double x, double lc, double sl, int lt, int lg) double qlogis(double p, double lc, double sl, int lt, int lg) double rlogis(double lc, double sl) double dnbeta(double x, double a, double b, double ncp, int lg) double pnbeta(double x, double a, double b, double ncp, int lt, int lg) double qnbeta(double p, double a, double b, double ncp, int lt, int lg) double rnbeta(double a, double b, double np) double dnf(double x, double df1, double df2, double ncp, int lg) double pnf(double x, double df1, double df2, double ncp, int lt, int lg) double qnf(double p, double df1, double df2, double ncp, int lt, int lg) double dnt(double x, double df, double ncp, int lg) double pnt(double x, double df, double ncp, int lt, int lg) double qnt(double p, double df, double ncp, int lt, int lg) double dweibull(double x, double sh, double sl, int lg) double pweibull(double x, double sh, double sl, int lt, int lg) double qweibull(double p, double sh, double sl, int lt, int lg) double rweibull(double sh, double sl) "],
["280_Rcpp_in_R.html", "Chapter 29 Rのコード中にRcppのコードを埋め込む", " Chapter 29 Rのコード中にRcppのコードを埋め込む Rcppのコードをファイルに保存せずに、Rのコードの中で記述することもできます。そのためには sourceCpp() cppFunction() evalCpp() を使う。 29.0.1 sourceCpp() sourceCpp() に対しては、Rcpp コードを記述したファイルへのパスを与える代わりに、RcppのコードをRの文字列として記述して与えることもできます。 src&lt;- &quot;#include &lt;Rcpp.h&gt; using namespace Rcpp; // [[Rcpp::export]] double rcpp_sum(NumericVector v){ double sum = 0; for(int i=0; i&lt;v.length(); ++i){ sum += v[i]; } return(sum); }&quot; sourceCpp(code = src) rcpp_sum(1:10) 29.0.2 cppFunction() cppFunction()を使うと「単一のRcpp関数」を手軽に作成することができます。その際には #include&lt;Rcpp.h&gt;とusing namespase Rcppの記述を省略できます。 src &lt;- &quot;double rcpp_sum(NumericVector v){ double sum = 0; for(int i=0; i&lt;v.length(); ++i){ sum += v[i]; } return(sum); } &quot; Rcpp::cppFunction(src) rcpp_sum(1:10) 29.0.3 evalCpp() evalCpp() を使うと手軽にRcppの式を評価することができます。 # double の最大値を調べる &gt; Rcpp::evalCpp(&#39;std::numeric_limits&lt;double&gt;::max()&#39;) [1] 1.797693e+308 "],
["290_R_in_Rcpp.html", "29.1 C++のソースにRのコードを埋め込む", " 29.1 C++のソースにRのコードを埋め込む C++ のコード内に R のコードを記述することもできます。 C++ コード内で /*** Rで始まるコメントの内に R のコードを書くと、sourceCpp() した時に、それが実行されます。・ #include&lt;Rcpp.h&gt; using namespace Rcpp; // [[Rcpp::export]] double rcpp_sum(NumericVector v){ double sum = 0; for(int i=0; i&lt;v.length(); ++i){ sum += v[i]; } return(sum); } /*** R rcpp_sum(1:10) */ "],
["300_environment.html", "Chapter 30 Environment 30.1 Environment オブジェクトの作成 30.2 環境にあるオブジェクトにアクセスする 30.3 新しい環境を作成する 30.4 メンバ関数 30.5 static メンバ関数", " Chapter 30 Environment Environment クラスを用いるとアクセスしたい環境を変数として保持し、その環境中の変数や関数にアクセスすることができます。 30.1 Environment オブジェクトの作成 Environment クラスのオブジェクトを作成する方法を下に示します。 Environment env(); //グローバル環境 Environment env = Environment::global_env(); //グローバル環境 Environment env(&quot;package:stats&quot;); // パッケージ stats 内の環境 Environment env(1); // オブジェクトのサーチパスの i 番目にある環境（i=1はグローバル環境） オブジェクトサーチパスを確認するには R の search() 関数を利用します。 &gt; search() [1] &quot;.GlobalEnv&quot; &quot;tools:RGUI&quot; &quot;package:stats&quot; [4] &quot;package:graphics&quot; &quot;package:grDevices&quot; &quot;package:utils&quot; [7] &quot;package:datasets&quot; &quot;package:methods&quot; &quot;Autoloads&quot; [10] &quot;package:base&quot; 30.2 環境にあるオブジェクトにアクセスする Environment オブジェクトを通して環境中の変数や関数にアクセスするためには [] 演算子または get() メンバ関数を用います。もしも、その環境に存在しない変数や関数にアクセスした場合には R_NilValue (NULL) が返ります。 // グローバル環境を取得します Environment env = Environment::global_env(); //グローバル環境にある変数を取得します NumericVector x = env[&quot;x&quot;]; //グローバル環境にある変数 x の値を変更します x[0] = 100; 30.3 新しい環境を作成する 関数 new_env() 関数を用いることで新しい空の環境を作成することができます。 30.3.1 new_env(size = 29) 新しい環境を返します。size は作成される環境のハッシュテーブルの初期サイズを指定します。 30.3.2 new_env(parent, size = 29) parent を親環境とする新しい環境を返します。size は作成される環境のハッシュテーブルの初期サイズを指定します。 30.4 メンバ関数 30.4.1 get(name) name で指定された名前のオブジェクトを取得します。見つからない場合は R_NilValue を返します。 30.4.2 ls(all) この環境にあるオブジェクトの一覧を文字列ベクトル返します。引数 all が true なら全てのオブジェクトを、false なら名前が . から始まるオブジェクトは除外します。 30.4.3 find(name) この環境、あるいは、その親環境から文字列 name で指定した名前のオブジェクトを取得します。見つからない場合は binding_not_found 例外が thow されます。 30.4.4 exists(name) この環境に文字列 name で指定した名前のオブジェクトが存在する場合には true を返します。 30.4.5 assign( name, x ) この環境にある文字列 name で指定した名前のオブジェクトに値 x を代入します。成功した場合には true を返します。 30.4.6 isLocked() この環境がロックされている場合には true を返します。 30.4.7 remove(name) この環境から文字列 name で指定した名前のオブジェクトを削除します。成功した場合には true を返します。 30.4.8 lock(bindings = false) この環境をロックします。binding = true の場合は、この環境の binding （Rのオブジェクト名とメモリ上のオブジェクト値の対応関係）もロックします。 30.4.9 lockBinding(name) この環境にある文字列 name で指定した binding をロックします。 30.4.10 unlockBinding(name){ この環境にある文字列 name で指定した binding のロックを解除します。 30.4.11 bindingIsLocked(name) この環境にある文字列 name で指定した binding がロックされている場合には true を返します。 30.4.12 bindingIsActive(name) この環境にある文字列 name で指定した binding がアクティブである場合には true を返します。 30.4.13 is_user_database() この環境がユーザーが定義したデータベース（“UserDefinedDatabase”）を継承している場合には true を返します。 30.4.14 parent() この環境の親環境を返します。 30.4.15 new_child(hashed) この環境を親とする新しい環境を作成します。hashed = true の場合は、作成した環境はハッシュテーブルを使用します。 30.5 static メンバ関数 30.5.1 Environment::global_env() グローバル環境を返します。 30.5.2 Environment::empty_env() ルート環境である空環境を返します。 30.5.3 Environment::base_env() base パッケージの環境を返します。 30.5.4 Environment::base_namespace() baseパッケージの名前空間を返す。 30.5.5 Environment::Rcpp_namespace() Rcpp パッケージの名前空間を返します。 30.5.6 Environment::namespace_env(package) 文字列 package で指定した名前のパッケージの名前空間を返します。Environment::namespace_env() を使った場合には、R であらかじめ library() 関数でパッケージをロードしていなくてもパッケージ内の関数を呼び出すことができますこれは R で パッケージ名::関数() という形式で呼び出した場合と同等です。それに加えて、パッケージ内で export されていない関数にもアクセスすることができます。これは Rで パッケージ名:::関数() という形式で呼び出した場合と同等です。 "],
["310_iterator.html", "Chapter 31 イテレーター", " Chapter 31 イテレーター イテレータ（反復子）とは、ベクトルなどの要素にアクセスするためのオブジェクトです。Rcpp のベクトルに対して標準 C++ のアルゴリズムを適用したい場合にはイテレータを利用します。なぜなら標準 C++ で提供されているアルゴリズムの多くはイテレータを使って処理を適用するデータの位置や範囲を指定するためです。 Rcpp のデータ構造には、それぞれ独自のイテレータ型が定義されています。 NumericVector::iterator IntegerVector::iterator LogicalVector::iterator CharacterVector::iterator DataFrame::iterator List::iterator 下の図はイテレータを使ってベクトルの要素にアクセスする方法を模式的に示しています。 i = v.begin() とするとイテレータ i は v の先頭要素を指し示します。 ++i は、i を1つ次の要素を指す状態に更新します。 --i は、i を1つ前の要素を指す状態に更新します。 i+1 は、i の1つ次の要素を指し示すイテレータを表します。 i-1 は、i の1つ前の要素を指し示すイテレータを表します。 *i は、i が指し示す要素の値を表します。 v.end() は v の末尾（最後の要素の１つ後）を指し示すイテレータを表します。 *(v.begin()+k) は v の k 番目の要素の値（v[k]）を表します。 次のコード例は、イテレータを使って NumericVectorの全ての要素を走査して値の合計値を求める例を示しています。 // [[Rcpp::export]] double rcpp_sum(NumericVector x) { double total = 0; for(NumericVector::iterator i = x.begin(); i != x.end(); ++i) { total += *i; } return total; } "],
["320_as_wrap.html", "Chapter 32 標準 C++ のデータ構造を利用する 32.1 標準 C++ データ構造と Rcpp データ構造の変換 32.2 標準 C++ データ構造を関数の引数や返値にする", " Chapter 32 標準 C++ のデータ構造を利用する 標準 C++ では vector list map set などの様々なデータ構造（コンテナ）が提供されています。それらはデータへのアクセス・追加・削除などの効率が異なるので、目的に応じて使い分けることで、実現したい処理をより効率よく実装できる場合があります。 例えば、ベクトルに要素を追加する処理を例にすると、Rcpp の Rcpp::Vector と標準 C++ の std::vector には、どちらにもベクトルの末尾に要素を追加するメンバ関数 push_back() が提供されていますが、その処理効率には大きな違いがあります。なぜなら Rcpp::Vector では push_back() メンバ関数を実行する度に追加した値を含むベクトル全体の値をメモリ上の他の場所にコピーする処理が発生するのに対して、std::vector では多くの場合には全体のコピーを行うことなく末尾に要素を追加することができるためです。 下に、std::vector を用いた例として、行列の要素の値が 0 ではない要素の行番号と列番号を取得する例を示します。 // [[Rcpp::export]] DataFrame matix_rows_cols(NumericMatrix m){ // 行列から値が 0 ではない要素の列番号と行番号を返します。 // 簡単のため行列は NA を含まない前提とします。 // 行数 I 、列数 J int I = m.rows(); int J = m.cols(); // 結果を標準 C++ コンテナの vector に格納します。 std::vector&lt;int&gt; rows, cols; //行番号と列番号を格納する変数 // 要素の数は最大で行列 m の要素数になり得るので // その分のメモリを先に確保します。 rows.reserve(m.length()); cols.reserve(m.length()); // 行列 m の全ての要素にアクセスして // 値が 0 ではない要素の行番号と列番号を保存します。 for(int i=0; i&lt;I; ++i){ for(int j=0; j&lt;J; ++j){ if(m(i,j)!=0.0){ rows.push_back(i+1); cols.push_back(j+1); } } } // 結果をデータフレームとして返します。 return DataFrame::create(Named(&quot;rows&quot;, rows), Named(&quot;cols&quot;, cols)); } 下に、いくつかの主要な標準 C++ データ構造の概要を示します。 標準 C++ データ構造 概要 vector 可変長配列：各要素はメモリ上で連続して配置されます。 list 可変長配列：各要素はメモリ上で分散して配置されます。 map, unordered_map 連想配列：キー・バリュー形式でデータを保持します。 set, unordered_set 集合：重複のない値の集合を保持します。 map は要素がキーの値でソートされた順に並びます。それに対して unordered_map では順番は保証されませんが要素の挿入とアクセスの速度に優ります。同様に、set は要素の値でソートされた順に並びます。unordered_set では順番は保証されませんが要素の挿入とアクセスの速度に優ります。 32.1 標準 C++ データ構造と Rcpp データ構造の変換 Rcpp のデータ構造と標準 C++ のデータ構造の変換には as&lt;T&gt;() 関数と wrap() 関数を用います。 as&lt;CPP&gt;(RCPP) : Rcpp データ構造（RCPP）を標準 C++ データ構造（CPP）に変換します wrap(CPP) : 標準 C++ データ構造（CPP）を Rcpp データ構造に変換します 下表に Rcpp と標準 C++ で変換可能なデータ構造の対応を示します。（+ は対応している、- 対応していないことを示しています。） Rcpp 標準 C++ as wrap Vector vector, list, deque + + List, DataFrame vector&lt;vector&gt;, list&lt;vector&gt; など + + 名前付き Vector map, unordered_map - + Vector set, unordered_set - + 次のコード例では、Rcpp の Vector と標準 C++ のシーケンス・コンテナ（ vector, list, deque など値が直列に並んでいるように扱えるコンテナ）を変換する例を示します。 NumericVector rcpp_vector = {1,2,3,4,5}; // Rcpp::Vector から std::vector への変換 std::vector&lt;double&gt; cpp_vector = as&lt; std::vector&lt;double&gt; &gt;(rcpp_vector); // std::vector から Rcpp::Vector への変換 NumericVector v1 = wrap(cpp_vector); 次のコード例では、標準 C++ のシーケンス・コンテナが入れ子になった2次元コンテナを DataFrame や List に変換する例を示します。 // using namespace std; // 要素となるベクトルの長さが全て等しい２次元ベクトルは // DataFrame に変換できます vector&lt;vector&lt;double&gt;&gt; cpp_vector_2d_01 = {{1,2},{3,4}}; DataFrame df = wrap(cpp_vector_2d_01); // 要素となるベクトルの長さが異なる２次元ベクトルは // List に変換できます vector&lt;vector&lt;double&gt;&gt; cpp_vector_2d_02 = {{1,2},{3,4,5}}; List li = wrap(cpp_vector_2d_02); 次のコード例では、標準 C++ の map&lt;key, value&gt; と unordered_map&lt;key, value&gt; は key を要素の名前、value を要素の型とした、名前付き Vector に変換されることを示します。 #include&lt;map&gt; // [[Rcpp::export]] NumericVector std_map(){ std::map&lt;std::string, double&gt; cpp_num_map; cpp_num_map[&quot;C&quot;] = 3; cpp_num_map[&quot;B&quot;] = 2; cpp_num_map[&quot;A&quot;] = 1; std::un&lt;std::string, double&gt; cpp_num_map; cpp_num_map[&quot;C&quot;] = 3; cpp_num_map[&quot;B&quot;] = 2; cpp_num_map[&quot;A&quot;] = 1; Listli li = List::create(cpp_num_map, cpp_num_map); } 実行結果 std::map ではキーの値でソートされているのに対して、std::unordered_map では順番が保証されないことがわかります。 &gt; std_map() [[1]] A B C 2 1 3 [[2]] A C B 2 3 1 32.2 標準 C++ データ構造を関数の引数や返値にする as() 関数や wrap() 関数で変換可能な標準 C++ データ構造は Rcpp 関数の引数や返値にすることもできます。そこでは R から Rcpp で記述した関数に値が渡される時、暗黙的に as() が呼ばれ、関数の返値が R に戻されるときには暗黙的に wrap() が呼ばれてデータが変換されます。 // [[Rcpp::plugins(&quot;cpp11&quot;)]] // [[Rcpp::export]] vector&lt;double&gt; times_two_std_vector(vector&lt;double&gt; v){ //暗黙的に as() が呼ばれる for(double &amp;x : v){ x *= 2; } return v; //暗黙的に wrap() が呼ばれる } "],
["330_STL.html", "Chapter 33 標準 C++ アルゴリズム", " Chapter 33 標準 C++ アルゴリズム 標準 C++ の &lt;algorithm&gt; と &lt;numeric&gt; ヘッダファイルでは様々な汎用アルゴリズムが提供されています。イテレータの章でも述べたように、その多くでは、イテレータを使ってアルゴリズムを適用する位置や範囲を指定します。 下のコード例では &lt;algorithm&gt; ヘッダファイルにある count() 関数を用いて、ベクトルに対して指定した値と等しい要素の数を数える例を示します。 #include &lt;algorithm&gt; // [[Rcpp::export]] int rcpp_count(){ // 文字列ベクトルの作成 CharacterVector v = CharacterVector::create(&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;C&quot;, NA_STRING); // 文字列ベクトル v から値が &quot;A&quot; である要素の数を数えます return std::count(v.begin(), v.end(), &quot;A&quot;); // 2 } なお、標準 C++ のクラスや関数などは std:: 名前空間の中で定義されているため std::vector のように std:: をつけて指定するか、 using namespace std; を記述して std 名前空間を利用するように指定します。 "],
["340_boost.html", "Chapter 34 Boost を利用する", " Chapter 34 Boost を利用する Boost ライブラリには標準 C++ よりもさらに先進的な機能が提供されています。 Boost ライブラリのうち、ヘッダー・ファイル・オンリーで使えるものについては、R のパッケージ BH をインストールすることで Rcpp でも利用できるようになります。 install.packages(&quot;BH&quot;) 自分でインストールした Boost についても、ヘッダーとライブラリーへのパスを指定すれば利用できます。 Sys.setenv(&quot;PKG_CXXFLAGS&quot;=&quot;-std=c++11 -I/opt/local/include -L/opt/local/lib/&quot;) コード例： 例：乱数生成器 #include &lt;boost/random.hpp&gt; #include &lt;boost/generator_iterator.hpp&gt; #include &lt;boost/random/normal_distribution.hpp&gt; // [[Rcpp::export]] NumericVector boostNormals(int n) { typedef boost::mt19937 RNGType; // select a generator, MT good default RNGType rng(123456); // instantiate and seed boost::normal_distribution&lt;&gt; n01(0.0, 1.0); boost::variate_generator&lt; RNGType, boost::normal_distribution&lt;&gt; &gt; rngNormal(rng, n01); NumericVector V(n); for ( int i = 0; i &lt; n; i++ ) { V[i] = rngNormal(); }; return V; } R, Rcpp, C++11, Boost で乱数生成器のパフォーマンス比較 Rの乱数生成器を呼び出す #include &lt;Rcpp.h&gt; using namespace Rcpp; // [[Rcpp::export]] NumericVector rcppNormals(int n) { return rnorm(n); } ベンチマーク library(rbenchmark) n &lt;- 10000 res &lt;- benchmark(rcppNormals(n), boostNormals(n), cxx11Normals(n), rnorm(n), order=&quot;relative&quot;, replications = 500) print(res[,1:4]) 結果 test replications elapsed relative 2 boostNormals(n) 500 0.402 1.000 3 cxx11Normals(n) 500 0.425 1.057 1 rcppNormals(n) 500 0.505 1.256 4 rnorm(n) 500 0.675 1.679 C++11やBoost のネイティブ乱数生成器が早いが、Rcpp版も健闘しています。どれも、ただのR関数よりは早い。 #include &lt;Rcpp.h&gt; // [[Rcpp::depends(BH)]] // One include file from Boost #include &lt;boost/date_time/gregorian/gregorian_types.hpp&gt; using namespace boost::gregorian; // [[Rcpp::export]] Rcpp::Date getIMMDate(int mon, int year) { // compute third Wednesday of given month / year date d = nth_day_of_the_week_in_month(nth_day_of_the_week_in_month::third, Wednesday, mon).get_date(year); date::ymd_type ymd = d.year_month_day(); return Rcpp::wrap(Rcpp::Date(ymd.year, ymd.month, ymd.day)); } IMM date は、毎月の３番目の水曜日のことを指す。Boost には mon 月 の N 週目の M 曜日を返す関数があります。nth_day_of_the_week_in_month(M, N, mon) getIMMDate(3, 2013) "],
["350_package.html", "Chapter 35 Rcppを用いたパッケージ作成 35.1 Rcppを用いたパッケージ作成の手順 35.2 roxygen2 パッケージを用いてパッケージのパッケージのドキュメントを作成する 35.3 自作パッケージで他のパッケージのC/C++関数を利用する 35.4 自作パッケージでサードパーティのC/C++ライブラリを利用する", " Chapter 35 Rcppを用いたパッケージ作成 このセクションでは自作のパッケージで Rcpp を利用する方法を解説します。 http://dirk.eddelbuettel.com/code/rcpp/Rcpp-package.pdf 通常のユーザーはパッケージを作成する必要はないと考えるかもしれません。しかし、Rcpp で書いた関数はパッケージとして保存しておくことを薦めます。なぜなら、パッケージ化しないでRcppで作成した関数を利用する場合には、毎回 sourceCppRcpp でコンパイルしてRにロードする必要があります。それに対して、パッケージ化すると、コンパイル済みのRcpp関数を保存しておき、使うときには library() でロードするだけで済むようになるためです。 35.1 Rcppを用いたパッケージ作成の手順 35.1.1 手動で自作パッケージを Rcpp に対応させる 自作パッケージを手動で設定する方法を以下に示します。（作成しているパッケージの名前を myPackage とします。） src/ フォルダを作成する C/C++ のソース・ファイルはこのフォルダの中に配置します。 DESCRIPTIONファイルに以下の記述を追加する LinkingTo: Rcpp Imports: Rcpp LinkingTo: は、ここで指定したパッケージが提供するC/C++のヘッダファイルを、自作パッケージから利用できるようにします。 Imports: は、ここで指定したパッケージが提供するRの関数を、この自作パッケージから利用可能にします。また、この自作パッケージがここで指定したパッケージに依存していることを明示します。 (Depends: も、ここで指定したパッケージが提供するRの関数を、この自作パッケージから利用可能にします。Importとの違いは、この自作パッケージをRにlibrary()でロードしたときに、ここで指定したパッケージもlibrary()でロードされるということ。) NAMESPACEファイルに以下の記述を追加する useDynLib(myPackage) exportPattern(&quot;^[[:alpha:]]+&quot;) importFrom(Rcpp, sourceCpp) useDynLib(myPackage)は、この自作パッケージ自身に含まれるコンパイルされた関数を、この自作パッケージ自身の R 関数から利用可能にします。（このパッケージのコンパイルされた関数のポインタ（アドレス）がこのパッケージのRの関数からアクセスできるようにする？） exportPattern(&quot;^[[:alpha:]]+&quot;) は、このパッケージで定義された R の関数のうち、どれをパッケージのユーザーから利用できるようにするか指定しています。ここでは正規表現を使って全ての関数を指定しています。（Rcppを使うと // [[Rcpp::export]] を付けて定義した C++ の関数と同名の R の関数が自動で作成される。それを exportPattern(&quot;^[[:alpha:]]+&quot;) によって、全てをRから利用可能にしている）。ちなみに export(foo, bar) とすると定義されたRの関数 foo と bar のみがユーザーから利用可能になります。 importFrom(Rcpp, sourceCpp) は、このパッケージ内の R の関数から、Rcpp パッケージの sourceCpp 関数を :: なしで呼び出し可能にしています。（このパッケージ内で sourceCpp と書くと Rcpp::sourceCpp と解釈される ）。ちなみに import(foo, bar) と書くと、このパッケージの内部でパッケージ foo と bar の全ての関数が :: なしで呼び出し可能になります。これはこのパッケージの中で library() を使ったのと同じ効果を持ちます。しかし import() を使って他のパッケージの関数を自作パッケージ内から利用可能にすることはできる限り避けた方が良いでしょう。その理由は２つあって、１つは他のパッケージと関数名の衝突が起こる恐れがあること、もう１つは、利用している関数のどれがどのパッケージの物なのかわかりにくくなるためです。 自作パッケージの中で他のパッケージの関数を利用する場合は、 DESCRIPTION ファイルの Imports: フィールドに他のパッケージを指定し、自作関数内では パッケージ名::関数名 の形式で利用するのが良いでしょう。どうしても必要なもの（例えば dplyr::&quot;%&gt;%&quot; など）だけ NAMESPACE ファイルで importfrom(dplyr, &quot;%&gt;%&quot;) で加えましょう。 35.1.2 Rcpp.package.skeleton() を利用する Rcppを用いたパッケージを新規に作成する際に、最も簡単な方法は Rcpp::Rcpp.package.skeleton() を用いる方法です。 Rcpp.package.skeleton( # パッケージ名 name = &quot;anRpackage&quot;, # パッケージに含めたいオブジェクトの名前（文字列ベクトルで指定） list = character(), # 引数 list で指定したオブジェクトを探す環境 environment = .GlobalEnv, # 作成するパッケージのフォルダの保存先 path = &quot;.&quot;, # TRUEなら既存のパッケージのフォルダを上書きする force = FALSE, # パッケージに含めたいコードが書かれたRファイルへのパスを指定する code_files = character(), # パッケージに含めたいコードが書かれたC++ファイルへのパスを指定する cpp_files = character(), # TRUEならRcppを用いたC++コード例をパッケージに追加する example_code = TRUE, # TRUEならパッケージに含めるC++コード例は Rcpp attributes を利用する attributes = TRUE, # TRUEなら作成するパッケージの雛形にModuleの例を含める module = FALSE, # パッケージの著者 author = &quot;Your Name&quot; # パッケージのメンテナー maintainer = if(missing( author)) &quot;Your Name&quot; else author, # パッケージのメンテナーのメールアドレス email = &quot;your@email.com&quot;, # パッケージのライセンス license = &quot;GPL (&gt;= 2)&quot; ) 使用例 Rcpp::Rcpp.package.skeleton(&quot;myPackage&quot;) 上のコードを実行すると myRcppPackage というパッケージのフォルダが作成されます。 35.1.3 devtools::use_rcpp() を用いる 既存の自作パッケージに Rcpp を利用した関数を追加したい場合には、devtools::use_rcpp() を利用する方法もあります。 use_rcpp( # パッケージのフォルダへのパスを指定する pkg = &quot;.&quot; ) 次の例では、最初に package.skeleton() でパッケージの雛形を作成してから、devtools::use_rcpp() でそのパッケージをRcppを利用するために必要な設定を行っています。 &gt; package.skeleton(&quot;myPackage&quot;) Creating directories ... Creating DESCRIPTION ... Creating NAMESPACE ... Creating Read-and-delete-me ... Saving functions and data ... Making help files ... Done. Further steps are described in &#39;./myPackage/Read-and-delete-me&#39;. &gt; devtools::use_rcpp(&quot;myPackage&quot;) Adding Rcpp to LinkingTo and Imports * Creating `src/`. * Ignoring generated binary files. Next, include the following roxygen tags somewhere in your package: #&#39; @useDynLib myPackage #&#39; @importFrom Rcpp sourceCpp NULL Then run document() この方法を用いた場合には、NAMESPACE には設定が追加されません。そこで、このパッケージのRコードのどこかに次の記述を追加してから devtools::document()を実行します。 詳しくは次のセクションを参照ください。 #&#39; @useDynLib myPackage #&#39; @importFrom Rcpp sourceCpp NULL 35.2 roxygen2 パッケージを用いてパッケージのパッケージのドキュメントを作成する RコードやC++コードの中にroxygenタグと呼ばれる特殊な文字列を記述することで、パッケージ関数のヘルプやNAMESPACEファイルの内容を生成させることができます。  roxygenタグからドキュメントのソースファイルを生成するには devtools::document() を実行します。 例えば、下の記述をパッケージ内のRコードのどこかに記述してから devtools::document() を実行すると、 #&#39; @useDynLib myPackage #&#39; @importFrom Rcpp sourceCpp NULL NAMESPACE ファイルに次の記述が加えられます。 importFrom(Rcpp,sourceCpp) useDynLib(myPackage) 35.3 自作パッケージで他のパッケージのC/C++関数を利用する Rのパッケージによっては、そのパッケージで定義されたC/C++の関数やクラスを他のパッケージから利用できるように公開しているものもあります。自作パッケージから、他のパッケージが公開しているパッケージを利用するには以下の方法を用います。 35.4 自作パッケージでサードパーティのC/C++ライブラリを利用する "],
["360_parallel.html", "Chapter 36 RcppParallel 36.1 RcppParallelの並列化の特徴 36.2 インストール 36.3 Worker 36.4 例：parallelFor() 36.5 例：parallelReduce() 36.6 パッケージで利用する場合", " Chapter 36 RcppParallel 公式サイト：http://rcppcore.github.io/RcppParallel/ RcppParallel は Rcpp で並列プログラミングを可能にするパッケージ。バックエンドとして Windows, OS X, Linux では Intel Threaded Building Blocks (TBB) ライブラリ、その他のプラットフォームでは TinyThread ライブラリを用いています。 36.1 RcppParallelの並列化の特徴 Rには既に他にも parallel や snow など、多くの並列化パッケージあるが、RcppParallel 並列化との間には重要な違いが存在します。 parallel や snow での並列化は マルチプロセス の方式であり、複数のRを別プロセスとして立ち上げて並列で実行します。そのため、元のRから並列計算を行うRにデータを転送する必要があります。１台のコンピュータでのみ並列計算を行う際にも並列プロセス間で socket 通信を介してデータをコピーするため、データが大きい場合には転送に非常に時間がかかってしまう。 一方、RcppParallelでの並列化は マルチスレッド です。そのため、１台のコンピュータの複数コアでの並列計算しか行うことができない。しかし、並列スレッドは元のRとメモリ上のデータを共有できるため、データ転送のコストがかからない。そのため1台のPCしかない場合にはマルチスレッドのほうがアドバンテージは非常に大きくなります。 これまで、R や Rcpp のAPIを使ったマルチスレッド・プログラミングは技術的ハードルが高いため、使えるのはエキスパートに限られていた。しかし、RcppParallelを使うと、スレッド並列化に必要な処理 を全て自動で行ってくれるので、ユーザーは実現したい処理の実装に集中できます。 36.2 インストール install.packages(&quot;RcppParallel&quot;) install_github(&quot;RcppParallel&quot;,&quot;RcppCore&quot;) Rcppソースに以下を追加 // [[Rcpp::depends(RcppParallel)]] #include &lt;RcppParallel.h&gt; 36.2.1 parallelFor, parallelReduce RcppParallel は parallelFor() と parallelReduce() の２つの関数を提供します。 void parallelFor(std::size_t begin, std::size_t end, Worker&amp; worker, std::size_t grainSize = 1) void parallelReduce(std::size_t begin, std::size_t end, Reducer&amp; reducer, std::size_t grainSize = 1) parallelFor``parallelReduce は Vectorと Matrix の begin から end-1 までの要素に対して worker reducer で定義された処理を並列で実行します。 parallelFor は入力データの各要素と出力データの各要素が１対１で対応するような処理 （例えば sqrt() や log()） を並列化する場合に用います。 parallelReduce は入力データの全要素を１つの値に集約するような処理 （例えば sum()やmean()） を並列化する場合に用います。 現状のRcppParallel(バージョン4.3.15) では parallelFor() parallelReduce() は DataFrame のカラムや List の要素毎の並列化には対応していません。 36.2.2 RVector, RMatrix マルチスレッド処理では、入力データや出力データの同じ要素に対して、異なる並列スレッドが同時にアクセスすることを防ぐ “スレッドセーフ” なデータアクセスが必要があります。 RcppParallel では Rcppの Vector や Matrix に対してスレッドセーフにアクセスするためのラッパー RVector RMatrixを提供しています。 //整数ベクターを RVector&lt;int&gt; に変換します。 IntegerVector v_int; RVector&lt;int&gt; vp_int(v_int); //実数行列を Rmatrix&lt;double&gt; に変換します。 NumericMatrix m_num; Rmatrix&lt;double&gt; mp_num(m_num); 36.3 Worker parallelFor parallelReduce で処理する内容は関数オブジェクトとして定義します。 parallelFor``parallelReduce に渡す関数オブジェクトは Worker クラスを継承して作成します。 36.4 例：parallelFor() parallelFor を使って、Matrix の各要素の平方根を計算します。 http://gallery.rcpp.org/articles/parallel-matrix-transform/ // [[Rcpp::depends(RcppParallel)]] #include &lt;RcppParallel.h&gt; using namespace RcppParallel; // Worker を継承して関数オブジェクト SquareRoot を定義する struct SquareRoot : public Worker { // 入力データを保持する内部変数 const RMatrix&lt;double&gt; input_data; // 出力データを保持する内部変数 RMatrix&lt;double&gt; output_data; //関数オブジェクトをインスタンス化するときに //入力データ・出力データを与えて内部変数を初期化する SquareRoot(const NumericMatrix input, NumericMatrix output) : input_data(input), output_data(output) {} // 関数オブジェクトの処理内容を定義する // parallelFor により、ある１つのスレッドで処理する範囲が // begin, end で与えられる void operator()(std::size_t begin, std::size_t end) { std::transform(input_data.begin() + begin, input_data.begin() + end, output_data.begin() + begin, ::sqrt); } }; // [[Rcpp::export]] NumericMatrix parallelMatrixSqrt(NumericMatrix x) { // 出力データを保存する Matrix を用意する NumericMatrix output(x.nrow(), x.ncol()); // 関数オブジェクトをインスタンス化する // このとき入力データ、出力データを渡す SquareRoot my_sqrt(x, output); // parallelFor()を使って、 // 入力データの全ての要素に対して関数オブジェクトを適用する // この中で output に値がセットされる parallelFor(0, x.length(), my_sqrt); // エラー：この記述は誤り parallelFor() の返値は void // output = parallelFor(0, x.length(), squareRoot); // 結果を出力 return output; } 36.5 例：parallelReduce() ベクターの要素の合計値を計算する http://gallery.rcpp.org/articles/parallel-vector-sum/ // [[Rcpp::depends(RcppParallel)]] #include &lt;RcppParallel.h&gt; using namespace RcppParallel; struct Sum : public Worker { // 入力値 const RVector&lt;double&gt; input_data; // 合計値 // この変数の型は RVector&lt;T&gt; の要素の型 T と一致している必要がある double value; //最初に入力データを取得するためのコンストラクタ Sum(const NumericVector input) : input_data(input), value(0) {} //分割された入力データ(sum.input_data)を受け取って、スレッドに渡すときに使われるコンストラクタ Sum(const Sum&amp; sum, Split) : input_data(sum.input_data), value(0) {} // input_data の要素番号 begin から要素番号 (end - 1) までの要素の合計値を計算する void operator()(std::size_t begin, std::size_t end) { value += std::accumulate(input_data.begin() + begin, input_data.begin() + end, 0.0); } // 他のスレッドで計算された結果を、このスレッドで計算された結果と、合体させるための処理 void join(const Sum&amp; rhs) { value += rhs.value; } }; // [[Rcpp::export]] double parallelVectorSum(NumericVector x) { // 入力データ x を渡して関数オブジェクトをインスタンス化 Sum sum(x); // 要素番号 0 から x.length() -1 までの要素の合計を求める parallelReduce(0, x.length(), sum); // 合計値を返す return sum.value; } 36.6 パッケージで利用する場合 各ファイルに以下の記述を追加する DESCRIPTION Imports: RcppParallel LinkingTo: RcppParallel SystemRequirements: GNU make NAMESPACE importFrom(RcppParallel, RcppParallelLibs) **src* PKG_LIBS += $(shell ${R_HOME}/bin/Rscript -e &quot;RcppParallel::RcppParallelLibs()&quot;) src\\Makevars.win PKG_CXXFLAGS += -DRCPP_PARALLEL_USE_TBB=1 PKG_LIBS += $(shell &quot;${R_HOME}/bin${R_ARCH_BIN}/Rscript.exe&quot; \\ -e &quot;RcppParallel::RcppParallelLibs()&quot;) "],
["370_link.html", "Chapter 37 リンク", " Chapter 37 リンク Rcpp Gallery : Rcpp を利用した様々なコード例が紹介されています。 Rcpp chapter in Advanced R : Rcpp の基本的な使い方が簡潔にまとめられています。 Rcpp Note : 非公式な Rcpp のリファレンス作成プロジェクト Rcpp Doxygen : Rcpp のソースコードを参照できる *R Internals : R 内部の技術についての解説。SXEPなどRについてわからない単語が出てきたら、とりあえずこの文章を参照するとよいです。 "],
["380_performance.html", "Chapter 38 パフォーマンス比較", " Chapter 38 パフォーマンス比較 RとRcppで記述した関数の実行速度を比較してみる。 例：ギブス・サンプラー http://gallery.rcpp.org/articles/gibbs-sampler/ この例では、２重の for ループの中で乱数を生成し、結果を行列に格納しています。 Rバージョン gibbsR &lt;- function(N,thin){ mat&lt;-matrix(0,nrow=N,ncol=2) x &lt;- 0 y &lt;- 0 for(i in 1:N){ for(j in 1:thin){ x &lt;- rgamma(1, 3, 1/(y*y+4)) y &lt;- rnorm(1, 1/(x+1), 1/sqrt(2*x+2)) } mat[i,] &lt;- c(x,y) } return(mat) } Rcppバージョン 以下のコードを “gibbs.cpp” というファイル名で保存します。 //gibbs.cpp #include &lt;Rcpp.h&gt; using namespace Rcpp; // [[Rcpp::export]] NumericMatrix gibbsCpp(int N, int thin) { NumericMatrix mat(N, 2); double x = 0, y = 0; for(int i = 0; i &lt; N; i++) { for(int j = 0; j &lt; thin; j++) { x = R::rgamma(3.0, 1.0 / (y * y + 4)); y = R::rnorm(1.0 / (x + 1), 1.0 / sqrt(2 * x + 2)); } mat(i, 0) = x; mat(i, 1) = y; } return(mat); } コンパイル &amp; 実行 library(Rcpp) sourceCpp(&#39;gibbs.cpp&#39;) gibbsCpp(100, 10) R との比較 RバージョンとRcppバージョンの関数の実行速度を比較してみる。その結果、Rcpp の方が56倍高速に実行されています。 この例のように、ベクターや行列の各要素への逐次アクセスするような場合に、Rcpp のアドバンテージが大きい。 library(rbenchmark) n &lt;- 2000 thn &lt;- 200 benchmark( gibbsR(n, thn), gibbsCpp(n, thn), columns = c(&quot;test&quot;, &quot;replications&quot;, &quot;elapsed&quot;, &quot;relative&quot;), order=&quot;relative&quot;, replications=10) 実行結果 test replications elapsed relative 2 gibbsCpp(n, thn) 10 1.454 1.000 1 gibbsR(n, thn) 10 81.427 56.002 "],
["390_rcpp_attributes.html", "Chapter 39 Rcpp Attributes 39.1 利用可能な Rcpp Attributes 39.2 Rcpp::interfaces 39.3 Rcpp::depends 39.4 Rcpp::plugins 39.5 Rcpp Attributes を処理する Rcpp の関数", " Chapter 39 Rcpp Attributes Rcpp Attributes はコンパイルに必要な情報をコンパイラに教えます。 39.1 利用可能な Rcpp Attributes 以下では、Rcppパッケージで利用可能な Rcpp Attributes の一覧とその機能を解説します。 39.1.1 Rcpp::export // [[Rcpp::export]] を記述した直下で定義した C++ の関数は R から利用可能になります。 // [[Rcpp::export]] を記述した関数は compileAttributes() により処理され、改変された関数が src/RcppExports.cpp に生成されます。さらに、src/RcppExports.cpp で定義された C++ 関数を呼び出すRの関数が R/RcppExports.R に生成されます。 また、デフォルトでは C++ で定義した関数名と同名の関数がRで利用可能になります。しかし、C++の関数名の命名規約とRの関数の命名規約が異なるために、Rの関数名として利用できる文字のうち、C++の関数名としては利用できない文字（.）もあります。その場合には下のように記述することで、Rで利用可能になる関数名を指定することができます。 // [[Rcpp::export(&quot;.myCppFunction&quot;)]] // [[Rcpp::export]] int fibonacci(const int x) { if (x == 0) return(0); if (x == 1) return(1); return (fibonacci(x - 1)) + fibonacci(x - 2); } // [[Rcpp::export(&quot;convolveCpp&quot;)]] NumericVector convolve(NumericVector a, NumericVector b) { int na = a.size(), nb = b.size(); int nab = na + nb - 1; NumericVector xab(nab); for (int i = 0; i &lt; na; i++) for (int j = 0; j &lt; nb; j++) xab[i + j] += a[i] * b[j]; return xab; } 39.2 Rcpp::interfaces // [[Rcpp::interfaces(r, cpp)]] 39.3 Rcpp::depends // [[Rcpp::depends(RcppArmadillo)]] // [[Rcpp::depends(Matrix, RcppGSL)]] 39.4 Rcpp::plugins // [[Rcpp::plugins(plugin1, plugin2)]] // [[Rcpp::plugins(cpp11)]] 39.5 Rcpp Attributes を処理する Rcpp の関数 39.5.1 compileAttributes() ソースコード中の Rcpp Attributes を読み取り、定義した C++ 関数を呼び出す R 関数を自動で生成する。 compileAttributes(pkgdir = &quot;.&quot;, verbose = getOption(&quot;verbose&quot;)) "]
]
